#!/bin/ksh
#
# @(#)12        1.3  src/htx/usr/lpp/htx/etc/scripts/stx_save.it, htx_linux, htxubuntu 3/10/07 11:53:11
#
#------------------------------------------------------------------------------
# Determine if echo interprets backslash formatting and correct if possible
  [ -x /bin/echo ] && {
     [ "X`(echo '\t') 2>/dev/null`" = 'X\t' ] && alias echo="/bin/echo -e"
  }

#------------------------------------------------------------------------------
#
# NOTE: save.it is non-destructive to system data and logs.  It can be
#       run multiple times.
#
#------------------------------------------------------------------------------
  tput clear
  echo "save.it - HTX Version v1.1"
  echo

# define some variables

  if [ "$1" = "ecg.all" ]
    then
     echo " ecg.all is a logical ecg "
     echo "please specify a valid ecg name to be stored"
     exit
  fi
  ecgFile="/usr/lpp/htx/ecg/$1"
  tmpRules="/tmp/htxcom.regrules"
  chrp="/usr/lib/boot/bin/dmpdt_chrp"


###############################################################################
# function definitions
function CLine
{
  echo "\r                                            \c"
  echo "\r$1\c"
}

function copyFiles
{
  bName=$(basename $1)
  [ -e $1 ] && { CLine $1; cp $1 $saveDir/$bName; }
}


###############################################################################
# Check to see if HTX is still running and abort if it is
  if [[ -n "$(ps -ef | grep hxssup 2>/dev/null | grep -v grep)" ]]
     then echo "HTX is still running:"
          echo
          ps -ef | grep -E "hxssup|hxe"
          echo
          echo "save.it can not be run while HTX is running - aborting"
          echo
          exit
  fi

###############################################################################
# Check to see if STX is still running and abort if it is
  if [[ -n "$(ps -ef | grep eservd 2>/dev/null | grep -v grep)" ]]
     then echo "STX is still running:"
          echo
          ps -ef | grep -E "eservd|hxe"
          echo
          echo "save.it can not be run while STX is running - aborting"
          echo
          exit
  fi



###############################################################################
# Setting Directory Name for Saving Data
  saveDir="/tmp/trial"

  if [[ -d $saveDir ]]
     then [ -d $saveDir.old ] && rm -R $saveDir.old
          mv $saveDir $saveDir.old
          mkdir $saveDir

     else mkdir $saveDir
  fi


###############################################################################
# Add/edit comment about trial
  comment="/tmp/.ttcomment"
  if [[ -e $comment ]]
     then echo
          cat $comment
          echo
          echo "Do you need to edit or add to these comments? (y/N): \c"
          read yn

     else echo "Answering 'yes' will result in a vi session to be opened for you to"
          echo "add comments about this specific trial.  Add comments? (y/N): \c"
          read yn
  fi

  typeset -u -L1 yn
  if ! [[ $yn = " " || $yn = "N" ]]
     then vi $comment
  fi


###############################################################################
# Copy HTX trial data (if exists)
  echo "\nCopying HTX trial data..."

  # chatmfail
    copyFiles /tmp/chatmfail

  # htxlinuxlevel
    copyFiles /usr/lpp/htx/htxlinuxlevel

  # htxerr
    copyFiles /tmp/htxerr

  # htx_hmcinfo
  # copyFiles /tmp/htx_hmcinfo

  # htx_sysdata
    copyFiles /tmp/htx_sysdata

  # htxsum
    copyFiles /tmp/htxsum

  # stx.start.stop.time
    copyFiles /tmp/stx.start.stop.time

  # htxmsg
    copyFiles /tmp/htxmsg

  # htxstats
    copyFiles /tmp/htxstats

  # .htx_profile
    copyFiles /usr/lpp/htx/.htx_profile

  # ecg
    echo "copying $ecgFile"
    copyFiles $ecgFile

  # motd
    copyFiles /etc/motd
    copyFiles /etc/~motd

  # sct
    for file in $(ls /tmp/sct* 2>/dev/null)
    do  copyFiles $file
    done

  # syserr
    for file in $(ls /tmp/syserr* 2>/dev/null)
    do  copyFiles $file
    done

  # htxstats of all ecgs
    for file in $(ls /tmp/htxstats* 2>/dev/null)
    do  copyFiles $file
    done

  # wbuf
    for file in $(ls /tmp/*wbuf* 2>/dev/null)
    do  copyFiles $file
    done

  # rbuf
    for file in $(ls /tmp/*rbuf* 2>/dev/null)
    do  copyFiles $file
    done

  # rerd
    for file in $(ls /tmp/*rerd* 2>/dev/null)
    do  copyFiles $file
    done

  # mem
    for file in $(ls /tmp/*mem* 2>/dev/null)
    do  copyFiles $file
    done

  # hxemul
    for file in $(ls /tmp/hxemul* 2>/dev/null)
    do  copyFiles $file
    done

  # errpt
    for file in $(ls /tmp/*.errpt 2>/dev/null)
    do  copyFiles $file
    done

  # cpugaurd
    for file in $(ls /tmp/*.cpug*.log 2>/dev/null)
    do  copyFiles $file
    done

  # aixlevel
  # copyFiles /usr/lpp/htx/aixlevel

  # gotInfo
    copyFiles /tmp/gotInfo

  # bootme.log
    copyFiles /tmp/bootme.log

  # eeh_data
    CLine "eeh_data"
    [ -d /tmp/eehdata ] && mv /tmp/eeh_data /tmp/trial 2>/dev/null

  # commo adapter xxx_warn
    for file in $(ls /tmp/*.warn 2>/dev/null)
    do  copyFiles $file
    done

  # trial.log
    copyFiles /usr/lpp/htx/trial.log


###############################################################################
# Collecting system info 
  echo "\rCollecting system information..."

  # df
    CLine "Running df"
    df > $saveDir/df 2> $saveDir/df.err
    [ -s $saveDir/df.err ] || rm $saveDir/df.err

  # ecalc
  #  CLine "Running ecalc"
  #  ecalc > $saveDir/entCalc 2> $saveDir/entCalc.err
  #  [ -s $saveDir/entCalc.err ] || rm $saveDir/entCalc.err

  # tcalc
  #  CLine "Running tcalc"
  #  tcalc > $saveDir/tokCalc 2> $saveDir/tokCalc.err
  #  [ -s $saveDir/tokCalc.err ] || rm $saveDir/tokCalc.err

  # errpt
  #  CLine "Running errpt"
  #  cat /var/log/platform | grep diagela > $saveDir/aixerr 2> $saveDir/aixerr.err
  #  [ -s $saveDir/aixerr.err ] || rm $saveDir/aixerr.err

  # errpt -a
  #  CLine "Running errpt -a"
  #  cat /var/log/platform > $saveDir/aixerr_a 2> $saveDir/aixerr_a.err
  #  [ -s $saveDir/aixerr_a.err ] || rm $saveDir/aixerr_a.err

  # iostat
    CLine "Running iostat"
    iostat > $saveDir/iostat 2> $saveDir/iostat.err
    [ -s $saveDir/iostat.err ] || rm $saveDir/iostat.err

  # lscfg -vp
    CLine "Running lscfg -vp"
    lscfg -vp > $saveDir/lscfg 2> $saveDir/lscfg.err
    [ -s $saveDir/lscfg.err ] || rm $saveDir/lscfg.err

  # lsdev -C
    CLine "Running lsdev -C"
    lsdev -C > $saveDir/lsdev 2> $saveDir/lsdev.err
    [ -s $saveDir/lsdev.err ] || rm $saveDir/lsdev.err

  # lslpp -ha
  #  CLine "Running lslpp -ha"
  #  lslpp -ha > $saveDir/lslpp 2> $saveDir/lslpp.err
  #  [ -s $saveDir/lslpp.err ] || rm $saveDir/lslpp.err

  # lsvpd
    CLine "Running lsvpd"
    lsvpd  > $saveDir/lsvpd 2> $saveDir/lsvpd.err
    [ -s $saveDir/lsvpd.err ] || rm $saveDir/lsvpd.err

  # lsslot -c pci
  #  CLine "Running lsslot -c pci"
  #  lsslot -c pci > $saveDir/lsslot 2> $saveDir/lsslot.err
  #  [ -s $saveDir/lsslot.err ] || rm $saveDir/lsslot.err

  # ps -ef
    CLine "Running ps -ef"
    ps -ef | grep -v "ps -ef" > $saveDir/ps-ef 2> $saveDir/ps-ef.err
    [ -s $saveDir/ps-ef.err ] || rm $saveDir/ps-ef.err

  # what /unix
  #  CLine "Running what /unix"
  #  what /unix > $saveDir/what_unix 2> $saveDir/what_unix.err
  #  [ -s $saveDir/what_unix.err ] || rm $saveDir/what_unix.err

  # lsdev -Cc proc*
    CLine "Total number of Processors"
  #  typeset -i TProc
    TProc=$(cat /proc/cpuinfo | grep processor | wc -l 2>/dev/null)
  #  [ -n "$TProc" ] && echo "Total number of Processors = $TProc" > $saveDir/processors
   echo "Total number of Processors = $TProc" > $saveDir/processors
    lProc=$(cat /proc/cpuinfo  2>/dev/null)
  #  [ -n "$lProc" ] && echo "$lProc" > $saveDir/processors
	 echo "$lProc" > $saveDir/processors

  # bootinfo
  #  CLine "Running bootinfo"
  #  bootb=$(bootinfo -b 2>/dev/null)
  #  [ -n "$bootb" ] && echo "boot device  = $bootb" > $saveDir/bootinfo
  #  bootK=$(bootinfo -K 2>/dev/null)
  #  [ -n "$bootK" ] && echo "kernel width = $bootK" >> $saveDir/bootinfo
  #  bootr=$(bootinfo -r 2>/dev/null)
  #  [ -n "$bootr" ] && echo "Real memory  = $bootr" >> $saveDir/bootinfo

  # memory
    CLine "Getting memory info"
    memory=$(cat /proc/meminfo | grep "MemTotal" | awk '{print $2}' 2>/dev/null)"kB"
    [ -n "$memory" ] && echo "memory = $memory" > $saveDir/memory

  # paging space
     CLine "Getting paging space info"
    cat /proc/meminfo | grep SwapTotal > $saveDir/pagingspace 2> $saveDir/pagingspace.err
    paging=$(cat /proc/meminfo | grep SwapTotal | awk '{print $2}' 2>/dev/null)
    echo "\npaging space = $paging" >> $saveDir/pagingspace
    [ -s $saveDir/pagingspace.err ] || rm $saveDir/pagingspace.err

  # ver
    CLine "Getting version info"
    /usr/lpp/htx/etc/scripts/ver > $saveDir/versions

  # dmpdt_chrp
  #    [ -e $chrp ] && { CLine "Getting dmpdt_chrp info"; $chrp > $saveDir/dmpdt_chrp; }


###############################################################################
# Append specific information to the copied$saveDir/trial.log
    echo >> $saveDir/trial.log
    echo "Total number of Processors = $TProc" >> $saveDir/trial.log
    echo "$lProc" >> $saveDir/trial.log
    echo >> $saveDir/trial.log
#    echo "boot device = $bootb" >> $saveDir/trial.log
#    echo "kernel width = $bootK" >> $saveDir/trial.log
    echo >> $saveDir/trial.log
    echo "memory = $memory" >> $saveDir/trial.log
    echo >> $saveDir/trial.log
    echo "paging space = $paging" >> $saveDir/trial.log


###############################################################################
# running lscfg -vp to discover the ROS and SP firmware levels
#  if [[ -e $chrp ]]
#     then CLine "Gathering System firmware levels"
#          sflev=$(lscfg -pv | grep -p "System Firmware:" | grep ROM)
#          sflev=${sflev##*"ROM Level.(alterable)......."}
#          if [[ -z "$sflev" ]]
#             then ttfw=$($chrp | grep -p============== \/openprom 2>/dev/null)
#                  ttfw=${ttfw#*ibm,fw-vernum_encoded}
#                  ttfw=${ttfw#*\[}
#                  ttfw=${ttfw%%]*}
#                  ttfw=${ttfw%%\.*}
#                  echo "    System FW Level: $ttfw" > $saveDir/firmware 2>/dev/null
#
#             else echo "    System FW Level: $sflev" > $saveDir/firmware 2>/dev/null
#
#          fi
#  fi

	CLine "Gathering System Firmware Levels"
        sflev=$(cat /proc/device-tree/openprom/ibm,fw-vernum_encoded)


###############################################################################
# running vgdisplay on all volume groups
  CLine "vgdisplay"
  for vg in $(vgdisplay | grep "VG Name" | awk '{print $3}')
    do
      echo "\nExecuting vgdisplay $vg" >> $saveDir/vgdisplay
      vgdisplay  $vg                   >> $saveDir/vgdisplay
  done


###############################################################################
# Find all devices and perform the lsattr command on them
#
#  CLine "lsattr -El"
#  [ -e "$saveDir/lsattr" ] && rm $saveDir/lsattr
#
#  for track in $(lsdev -C | awk '{print $1}' | grep -v fscsi)
#  do  echo "\nExecuting lsattr $track" >> $saveDir/lsattr
#      lsattr -El $track                >> $saveDir/lsattr
#  done


###############################################################################
# Find all buses and perform the lsresource command
#  CLine "lsresource -l"
#  [ -e "$saveDir/lsresource" ] && rm $saveDir/lsresource
#
#  for bus in $(lsdev -C | grep Bus | awk '{print $1}')
#  do  echo "\nExecuting lsresource on $bus" >> $saveDir/lsresource
#      lsresource -l $bus                    >> $saveDir/lsresource
#  done


###############################################################################
# Recording network statistics (regardless if network was setup)
  echo "\rRecording any network statistics..."

  CLine "netstat -s"
  echo "\nExecuting netstat -s"  > $saveDir/netstat          
    netstat -s                  >> $saveDir/netstat 2>/dev/null

  if [[ -n $(grep hxecom $ecgFile 2>/dev/null) ]]
     then CLine "netstat -D"
          echo "\nExecuting netstat -D" >> $saveDir/netstat          
          netstat -D                    >> $saveDir/netstat 2>/dev/null
  fi

  CLine "netstat -in"
  echo "\nExecuting netstat -in" >> $saveDir/netstat          
    netstat -in                  >> $saveDir/netstat 2>/dev/null

  CLine "netstat -m"
  echo "\nExecuting netstat -m"  >> $saveDir/netstat          
    netstat -m                   >> $saveDir/netstat 2>/dev/null


# run tokstat on all tok*: found in rules files
#  CLine "tokstat -d"
#  [ -e "$saveDir/tokstat" ] && rm $saveDir/tokstat
#
#  for tok in $(grep -p -E "\"hxecom\"|\"hxecom_t\"" $ecgFile 2>/dev/null | grep "tok" | grep ":")
#  do  tokNumRSide=${tok%%:*}
#      tokNum=${tokNumRSide#*tok}
#      echo "\nExecuting tokstat tr$tokNum" >> $saveDir/tokstat
#      tokstat -d tr$tokNum                 >> $saveDir/tokstat
#  done
#
## run entstat on all ent*: found in rules files
#  CLine "entstat -d"
#  [ -e "$saveDir/entstat" ] && rm $saveDir/entstat
#
#  for ent in $(grep -p -E "\"hxecom\"|\"hxecom_t\"" $ecgFile 2>/dev/null | grep "ent" | grep ":")
#  do  entNumRSide=${ent%%:*}
#      entNum=${entNumRSide#*ent}
#      echo "\nExecuting entstat ent$entNum" >> $saveDir/entstat
#      entstat -d ent$entNum                 >> $saveDir/entstat
#  done
#

# run fddistat on all fddi*: found in rules files
#  CLine "fddistat -d"
#  [ -e "$saveDir/fddistat" ] && rm $saveDir/fddistat
#
#  for fddi in $(grep -p -E "\"hxecom\"|\"hxecom_t\"" $ecgFile 2>/dev/null | grep "fddi" | grep ":")
#  do  fddiNumRSide=${fddi%%:*}
#      fddiNum=${fddiNumRSide#*fddi}
#      echo "\nExecuting fddistat fddi$fddiNum" >> $saveDir/fddistat
#      fddistat -d fddi$fddiNum                 >> $saveDir/fddistat
#  done
#

# run atmstat on all atm*: found in rules files
#  CLine "atmstat -d"
#  [ -e "$saveDir/atmstat" ] && rm $saveDir/atmstat
#
#  for atm in $(grep -p -E "\"hxecom\"|\"hxecom_t\"" $ecgFile 2>/dev/null | grep "atm" | grep ":")
#  do  atmNumRSide=${atm%%:*}
#      atmNum=${atmNumRSide#*atm}
#      echo "\nExecuting atmstat atm$atmNum"    >> $saveDir/atmstat
#      atmstat -d atm$atmNum                    >> $saveDir/atmstat
#  done


# run hdlcstat on all hdlc*: found in rules files
#  CLine "hdlcstat -d"
#  [ -e "$saveDir/hdlcstat" ] && rm $saveDir/hdlcstat
#
#  for hdlc in $(grep -p -E "\"hxecom\"|\"hxecom_t\"" $ecgFile 2>/dev/null | grep "hdlc" | grep ":")
#  do  hdlcNumRSide=${hdlc%%:*}
#      hdlcNum=${hdlcNumRSide#*hdlc}
#      echo "\nExecuting hdlcstat hdlc$hdlcNum"    >> $saveDir/hdlcstat
#      hdlcstat -d hdlc$hdlcNum                    >> $saveDir/hdlcstat
#  done


###############################################################################
# Copies any sig_* files to the save dir
  for file in $(ls /tmp/sig_* 2>/dev/null)
  do  copyFiles $file
  done


###############################################################################
# Moves any checkstop files to the save dir
#  CLine "Saving any checkstop files..."
#  for checkfile in $(find /usr/lib/ras -name "checkstop*" -print)
#  do  mv $checkfile $saveDir/$checkfile
#  done
#

###############################################################################
# Moves any core files to the save dir
  CLine "Saving any core files..."
  for corefile in $(find /usr/lpp/htx -name "core" -print)
  do  echo ".\c"
      CoreFile=$(echo "$corefile" | sed  "s/\//\./g")
      CoreFile=${CoreFile#\.}
      mv $corefile $saveDir/$CoreFile
  done


###############################################################################
# Collects SSA specific information, if available  (Script from Hursley, Eng)
#  CLine "Saving any SSA information..."
#  if [[ -n $(lsdev -C | grep ssa) ]]
#     then if [[ -d /tmp/ssa_testcode ]]
#             then /tmp/ssa_testcode/record_SSA_state >> $saveDir/ssa 2>/dev/null
#             else record_SSA_state                   >> $saveDir/ssa 2>/dev/null
#          fi
#  fi


###############################################################################
# Captures PCI information
  CLine "Saving any PCI bus information..."
  for PCI in $(lsdev -C | grep "PCI Bus" | awk '{print $1}')
  do  /etc/methods/cfgbus_pcic -l $PCI -d >/dev/null 
      mv BUS.out $saveDir/$PCI
  done


###############################################################################
# Save rules files used in test (based on ecg file)
  CLine "Saving rules files used in test..."
  typeset -i linesRead=0 totalLines
  grep reg_rules $ecgFile 2>/dev/null | grep -v '""' | sort -u > $tmpRules
  tmpCount=$(wc -l $tmpRules)
  tmpLines=${tmpCount%$tmpRules}
  typeset totalLines=$tmpLines

  while [[ $linesRead -lt $totalLines ]]
  do    let linesRead=$linesRead+1
        Line=$(head -$linesRead $tmpRules | tail -1)
        RHalf=${Line#*\"}
        RulesFile=${RHalf%%\"*}
        RulesFileShort=${RulesFile#*\/}
        RulesFileLeft=${RulesFile%\/*}
        cp /usr/lpp/htx/rules/reg/$RulesFile \
           $saveDir/rules.$RulesFileLeft.$RulesFileShort 2>/dev/null
  done
  rm $tmpRules


###############################################################################
# Find all devices and performing the odmget command
#  CLine "Recording odm data of all devices..."
#  [ -e "$saveDir/odmget" ] && rm $saveDir/odmget
#
#  for track in $(lsdev -C | awk '{print $1}')
#  do  echo "\nExecuting odmget $track" >> $saveDir/odmget
#      odmget -q"name=$track" CuDv      >> $saveDir/odmget
#  done


###############################################################################
# Find all scraid devices and record the individual disk VPD info
#  CLine "Recording any scraid data..."
#  [ -e "$saveDir/scraid" ] && rm $saveDir/scraid

#function listArrays
#{
#  adapterLocation=`lsdev -Cl $1 | awk '{print $3}'`
#  adapterScsiId=`echo $adapterLocation | cut -c1-5`
#
## Get all of the Available hdisks
#  hdisks=`lsdev -C -tarray -sscraid -SA -F name`
#  if [ -n "$hdisks" ]
#     then for ii in $hdisks
#          do  hdiskLocation=`lsdev -Cl $ii | awk '{print $3}'`
#              hdiskScsiId=`echo $hdiskLocation | cut -c1-5`
#              if [ $hdiskScsiId = $adapterScsiId ]
#                 then /usr/bin/scraidmgr -C -l $ii
#                      [ $? -ne 0 ] && return
#              fi
#          done
#  fi

# Get all of the Defined hdisks
#  hdisks=`lsdev -C -tarray -sscraid -SD -F name`
#  if [ -n "$hdisks" ]
#     then for ii in $hdisks
#          do  hdiskLocation=`lsdev -Cl $ii | awk '{print $3}'`
#              hdiskScsiId=`echo $hdiskLocation | cut -c1-5`
#              if [ $hdiskScsiId = $adapterScsiId ]
#                 then /usr/bin/scraidmgr -J -l $ii
#                      [ $? -ne 0 ] && return
#              fi
#          done
#  fi
#}

#  for raid in $(lsdev -C | grep "scraid" | awk '{print $1}')
#  do  listArrays $raid >> $saveDir/scraid
#      for disks in $(/usr/bin/scraidmgr -l $raid -B | grep -v ":N:" | grep -v drive | cut -c1-2)
#      do  echo "             " $disks" - "$(/usr/bin/scraidmgr -l $raid -P -y$disks) >> $saveDir/scraid
#      done
#  done
#

###############################################################################
# Running NVRAM dump
#  CLine "Running nvdump53..."
#  /usr/lpp/htx/etc/scripts/nvdump53 -a > $saveDir/nvramDump 2>/dev/null
#  if [[ $? -eq 0 ]]
#     then echo
#          CLine "Running nvboot..."
#          /usr/lpp/htx/etc/scripts/nvboot > $saveDir/boottime  2>/dev/null
#  fi
#  echo


###############################################################################
# If exists, will run judge script
#  CLine "Running judge script - Please be patient..."
#  /usr/lpp/htx/etc/scripts/stx_judge quiet
#  echo


###############################################################################
# Change to $saveDir and create an html web page of this trial named index.html
#  CLine "Running create.trial.index script - Please be patient..."
  cd $saveDir
#  /usr/lpp/htx/etc/scripts/create.trial.index quiet


###############################################################################
# change file permissions to 644
  for file in $(find . -type f)
  do  chmod 644 $file
  done


###############################################################################
# Ask to view the trial summary file
#  echo "Do you want to view the trial summary? (y/N): \c"
#  read ans
#  typeset -u -L1 ans
#  if ! [[ $ans = " " || $ans = "N" ]]
#     then vi /tmp/trial/summary
#  fi


###############################################################################
# Save results to floppy in backup/restore format
  echo "Do you want to BACKUP this trial to floppy? (y/N): \c"
  read ans
  typeset -u -L1 ans
  if ! [[ $ans = " " || $ans = "N" ]]
     then echo "Changing directory to $saveDir"
          cd $saveDir
          rm trialData* 2>/dev/null

          echo "Creating one tar'd file from all files in directory $saveDir"
               tar -cf trialData.tar *

          echo "Compressing file trialData"
               compress -v trialData.tar

          echo "writing undo script..."
          echo "uncompress trialData.tar.Z"  >> undo
          echo "tar -xvf trialData.tar"      >> undo
          echo "echo 'Data uncompressed'"    >> undo
          echo "rm trialData.tar undo"       >> undo
               chmod +x undo

          echo
          echo "Writing to floppy"
               ls undo trialData.tar.Z | backup -ivpq
               rm undo trialData.tar.Z

          echo "________________________________________________________________"
          echo "\nUse 'restore -x' to restore data from floppy, then type 'undo'"
  fi

  echo "Done - Trial data was saved in directory $saveDir\n"


###############################################################################
# If exists, will run a post save.it script named save.it.post
  /usr/lpp/htx/etc/scripts/save.it.post 2>/dev/null


###############################################################################
# If exists, removes /tmp/.fresh to let fresh know that save.it has been run
  [ -e /tmp/.fresh ] && rm /tmp/.fresh

