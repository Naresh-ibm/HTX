#!/usr/bin/perl -w

use Getopt::Long;

###############################################################################
#Name: create_all_mdt_with_tpsm
#Purpose: All mdt's are copied to new mdt file (name ending with _pm). The new 
#         mdt's will have tpsm stanza concatenated in them.
#Arguments: None. 
###############################################################################

sub parseOptions
{
	#All arguments are passed by reference
	my($patch_all, $new_mdt, $in_mdt,$base_mdt,$pr) = @_;
	my $help = 0;

	GetOptions('help|?' => \$help, 'pallmdt=i' => $patch_all, 'new_mdt=s' => $new_mdt, 'mdt=s' => $in_mdt, 'base_mdt=s' => $base_mdt, 'priority=i' => $pr); 

         if( $help )
	{
		print "Name:".$0."\n";
	        print "Purpose: Add given MDT stanzas to all or subset of other MDTs.\n";
	        print "         The script creates new files and do not patch existing MDTs.\n";
		print "Arguments:\n";
		print "    help => Print this help\n";
		print "    new_mdt => new MDT to be added ex:mdt.bu.hot \n";
		print "    base_mdt  => Base MDT to be copied to new MDT ex: mdt.bu.characterization\n";
		print "    mdt => Powermixer mdts ex:mdt.pm_rdp_smt1\n";
                print "    priority => priority given to the new mdt created 1=highest to 19=lowest\n";
		exit 0;
	}
	if($$new_mdt eq "")
	{
		 $$new_mdt = "mdt.pm_p8_temp";
	}
	if($$in_mdt eq "")
	{
		 $$in_mdt = "mdt.pm";
	}
	chomp($$new_mdt);
	chomp($$in_mdt);
        chomp($$base_mdt);
        chomp($$pr);
}

#Search if MDT passed as argument is present in exclude list.
#Return 0 if found else 1.
sub avail_exclude_list
{
	 my ($mdt, @list) = @_;
	 my $i;

	 chomp($mdt);
    #print("TO search: $mdt\n");

	 for($i=0; $i<@list; $i++)
	 {
		  chomp($list[$i]);
        #print("comparing $mdt with $list[$i]\n");
		  if($mdt eq $list[$i])
		  {
				return 0;
		  }
	 }
	 return 1;
}

sub cat_pm_stanza_update_priority 
{
my($PR,$SCRIPTPATH,$NEW_MDT,$MDTPATH,$IN_MDT) = @_;
$NEW_PRIORITY = "priority = $PR               * priority (1=highest to 19=lowest)";
`(cat $MDTPATH/$IN_MDT | sed 's/priority.*//' && echo  "\t$NEW_PRIORITY") |  $SCRIPTPATH/create_mdt_without_devices.awk default >> $MDTPATH/$NEW_MDT`;
}


sub update_global_var
{
open FH, "/usr/lpp/htx/mdt/mdt.bu_hot";
while(<FH>)
{
 if($_ =~ m/reg_rules(\s*)=(\s*)\"hxestorage\/(\w+)\"/)
   {
    $fname = $3;
    push(@hxestorage_rules,$fname);
   }
}
foreach $rules(@hxestorage_rules)
{
 if(-e "/usr/lpp/htx/rules/reg/hxestorage/$rules.bu_hot")
   {
    #print "\n not editing /usr/lpp/htx/rules/hxestorage/$rules because /usr/lpp/htx/rules/reg/hxestorage/$rules.bu_hotfile exists!!";
    next;
   }
 print "\nediting /usr/lpp/htx/rules/hxestorage/$rules,creating new rule /usr/lpp/htx/rules/reg/hxestorage/$rules.bu_hot";

 open RULES_FH, "< /usr/lpp/htx/rules/reg/hxestorage/$rules" or die "cannot open file $!";

 open RULES_BU_HOT_FH,"> /usr/lpp/htx/rules/reg/hxestorage/$rules.bu_hot" or die "cannot open file $!" ;

 $rule_id_flag = 0;

 while(<RULES_FH>)
   {
    if($rule_id_flag == 1)
      {
       print RULES_BU_HOT_FH "global_var = hang_time 1800\n";
      }
       else {print RULES_BU_HOT_FH "$_"};

   if($_ =~ m/rule_id/)
      {
       $rule_id_flag = 1;
      }else{$rule_id_flag = 0;}
   }
 close RULES_FH;
 close  RULES_BU_HOT_FH;
}
close FH;

open BU_HOT_FH, "< /usr/lpp/htx/mdt/mdt.bu_hot" or die "cannot open file mdt.bu_hot";
open BU_HOT_TEMP_FH, "> /usr/lpp/htx/mdt/mdt.bu_hot_temp" or die "cannot open file mdt.bu_hot_temp" ;
while(<BU_HOT_FH>)
{
 if($_ =~ m/reg_rules(\s*)=(\s*)\"hxestorage\/(\w+)\"/)
   {
    print BU_HOT_TEMP_FH "\treg_rules = \"hxestorage\/$3.bu_hot\"    *reg\n";
    next;
   }
   if($_ =~ m/emc_rules(\s*)=(\s*)\"hxestorage\/(\w+)\"/)
   {
    print BU_HOT_TEMP_FH "\temc_rules = \"hxestorage\/$3.bu_hot\"    *emc\n";
    next;
   }
  print BU_HOT_TEMP_FH "$_";
}
close BU_HOT_FH;
close BU_HOT_TEMP_FH;

`cp /usr/lpp/htx/mdt/mdt.bu_hot_temp /usr/lpp/htx/mdt/mdt.bu_hot`;
`rm /usr/lpp/htx/mdt/mdt.bu_hot_temp`;
#`rm /usr/lpp/htx/mdt/mdt.bu.characterization`;
}


my $PATCH_ALL = 0;
my $NEW_MDT = '';
my $IN_MDT = '';
my $BASE_MDT = '';
my $PR = 0;
parseOptions(\$PATCH_ALL, \$NEW_MDT, \$IN_MDT,\$BASE_MDT,\$PR);

#print "PATCH_ALL = $PATCH_ALL\n";
#print "NEW_MDT = $NEW_MDT\n";
#print "IN_MDT = $IN_MDT\n";
#print "BASE_MDT = $BASE_MDT\n";
#print "PRIORITY = $PR\n;

my $SCRIPTPATH = "/usr/lpp/htx/etc/scripts/";
my $MDTPATH = "/usr/lpp/htx/mdt/";
my @EXCLUDE_MDT_LIST = ("$IN_MDT", "mdt.readme");
my @ALLMDT = `find $MDTPATH -name \"*\" -prune -exec ls -1 \{\} \\;`;
my @INCLUDE_MDT_LIST;


if($PATCH_ALL == 1)
{
	 @INCLUDE_MDT_LIST = @ALLMDT;
}
else
{        
	 @INCLUDE_MDT_LIST = ("$BASE_MDT");
}

#Check validity of input MDT
if( avail_exclude_list("$IN_MDT", @ALLMDT) != 0 )
{
	 print "ERROR in $0: Input MDT not found. Exiting.\n";
	 exit(0);
}

my $i;
my $MDT;


for($i=0; $i<@INCLUDE_MDT_LIST; $i++)
{
	 $MDT = $INCLUDE_MDT_LIST[$i];
	 chomp($MDT);
	  
	
        if($MDT =~ /$NEW_MDT/)
	 {
        print "MDT ALREADY CREATED: $MDT\n";
		  next;
	 }
     

	 if( (avail_exclude_list("$MDT"), @EXCLUDE_MDT_LIST) != 0) #Not in exclude list
	 {        
		  system("cp $MDTPATH/$MDT $MDTPATH/$NEW_MDT");
           if($PR == 0){
                              system("cat $MDTPATH/$IN_MDT | $SCRIPTPATH/create_mdt_without_devices.awk default >> $MDTPATH/$NEW_MDT");
                  }
       else{
          cat_pm_stanza_update_priority($PR,$SCRIPTPATH,$NEW_MDT,$MDTPATH,$IN_MDT);
       }
      
        print "Creating $NEW_MDT...\n";
        $NEW_ECG = $NEW_MDT;
        $NEW_ECG =~ s/mdt(.*)/ecg$1/;
        system("ln -sf $MDTPATH/$NEW_MDT /usr/lpp/htx/ecg/$NEW_ECG"); 
	 }
        if( $MDT =~ /mdt.bu.characterization/ && $NEW_MDT =~ m/mdt.bu_hot/ )
          {
           print "new mdt is mdt.bu_hot\n";
           update_global_var();
          }
}

