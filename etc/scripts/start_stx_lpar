#!/bin/sh

# @(#)42  1.5  src/htx/usr/lpp/htx/etc/scripts/start_stx_lpar, htxconf, htxubuntu 10/30/15 12:07:35

function terminate_stx {
        if [ "$1" = "SIGNAL" ]
        then
		echo
                echo "SIGTERM signal received."; echo
                /collect_shift_logs
        fi
        echo "Shutting down STX."
        stx -d
        exit
}

function display_progress {
	echo -n "CYCLES: "
	for dev in $(cat /tmp/mdt_devices)
	do
	cycles=`cat /tmp/shift/${dev}_cycles`
	echo -n "$dev = $cycles, "
	done
	echo
	echo "RUNNING MDT = `cat $MDT_NAME_FILE`,  RUN_TIME = `cat $RUN_TIME_FILE` minutes,  LAST_UPDATE_TIME = `cat $LAST_UPDATE_TIME_FILE`" ;
	echo
}

trap 'terminate_stx SIGNAL' TERM

# Set values for command fail counter and allowed threahold for it.
cmd_fail_count=0
CMD_FAIL_THRESHOLD=5

# Counter for exerciser stats display.
display_counter=0

# Start STX daemon.
echo "Starting STX daemon."
echo "CMD# stx -k -l -r -x" ; date
stx -k -l -r -x
if [ $? -ne 0 ]
then
	echo "ERROR: STX daemon could not be started on LPAR". | tee $ERROR_LOG_FILE; echo
	echo $ERROR > $STATUS_FILE
	/collect_shift_logs $ERROR
	exit
else
	echo "STX daemon successfully started."; echo
fi

# Check if mdt file is present on LPAR.
if [ ! -f $MDT ]
then
        echo "ERROR: File $MDT not present on LPAR. Terminating test." | tee $ERROR_LOG_FILE; echo
        echo $ERROR > $STATUS_FILE
	/collect_shift_logs $ERROR
	terminate_stx
fi

# Find devices present in mdt.
awk '$1 ~ /:/' $MDT | grep -v default | tr -d '[0-9]:' | sed -e 's/sd[a-z]*/sd/' | sort | uniq > /tmp/mdt_devices
dev_count=`wc -l /tmp/mdt_devices | awk '{print $1}'`
if [ $dev_count -eq 0 ]
then
        echo "ERROR: No devices present in $MDT_NAME file. Terminating test." | tee $ERROR_LOG_FILE; echo
        echo $ERROR > $STATUS_FILE
	/collect_shift_logs $ERROR
	terminate_stx
else
        echo "Found below type of devices in $MDT"
        cat /tmp/mdt_devices; echo
fi

# Update default device cycle count.
for dev in $(cat /tmp/mdt_devices)
do
        echo 0 > /tmp/shift/${dev}_cycles
done

# Start mdt.
echo "Starting $MDT_NAME"
echo "CMD# esrv -sut localhost -run -ecg $MDT" ; date
esrv -sut localhost -run -ecg $MDT 

if [ $? -ne 0 ]
then 
	echo "ERROR: MDT $MDT_NAME could not be started." | tee $ERROR_LOG_FILE; echo
	echo $ERROR > $STATUS_FILE # Update run status as ERROR 
	/collect_shift_logs $ERROR
	terminate_stx
else
	echo "MDT $MDT_NAME successfully started."; echo
	echo $RUNNING > $STATUS_FILE  # Update run status as RUNNING
fi


# Sleep for few seconds allowing all exers to start cycling. 
echo "Sleeping for 30 seconds for all exerciser copies to get started."; echo
sleep 30 


# Display exerciser status.
echo "CMD#: esrv -sut localhost -status -ecg $MDT"; date
esrv -sut localhost -status -ecg $MDT 
if [ $? -ne 0 ]
then
	cmd_fail_count=`expr $cmd_fail_count + 1`
	echo "run status could not be collected, cmd_fail_count = $cmd_fail_count"
fi
echo

# Collect stats w/o it being displayed. /tmp/htxstats file should be updated here.
esrv -sut localhost -getstats -ecg $MDT >/dev/null 2>&1
if [ $? -ne 0 ]
then
	echo "CMD# esrv -sut localhost -getstats -ecg $MDT"
        cmd_fail_count=`expr $cmd_fail_count + 1`
        echo "Exerciser stats could not be collected, cmd_fail_count = $cmd_fail_count"
fi

# Start progress updation and error polling.
while true
do
	# Check for command fail count. Stop test if command fail count increases fail threshold
	if [ $cmd_fail_count -gt $CMD_FAIL_THRESHOLD ]
	then
		echo "ERROR: Too many esrv command failures seen. Terminating test."  | tee $ERROR_LOG_FILE
		echo "CMD_FAIL_THRESHOLD = $CMD_FAIL_THRESHOLD, cmd_fail_count = $cmd_fail_count" | tee -a $ERROR_LOG_FILE; echo
                echo $ERROR > $STATUS_FILE
		/collect_shift_logs $ERROR
		terminate_stx
	fi

	# Update mdt run time
	run_time=`esrv -sut localhost -get_run_time -ecg $MDT | awk '/Run_time/ {print $3}'`
	if [ -z "$run_time" ] 
	then
		cmd_fail_count=`expr $cmd_fail_count + 1`
		echo "CMD# esrv -sut localhost -get_run_time -ecg $MDT"
		echo "runtime command failed. cmd_fail_count = $cmd_fail_count"
	else		
		echo $run_time > $RUN_TIME_FILE
	fi		

	# Update last update time
	last_update_time=`esrv -sut localhost -get_last_update_time -ecg $MDT | awk '/Last_update_time/ {print $3}'`
        if [ -z "$last_update_time" ]
        then
		cmd_fail_count=`expr $cmd_fail_count + 1`
		echo "CMD# esrv -sut localhost -get_last_update_time -ecg $MDT"
                echo "last_update_time command failed. cmd_fail_count = $cmd_fail_count"
		last_update_time=`cat $LAST_UPDATE_TIME_FILE`  # Fill in last value.
        else
		echo $last_update_time > $LAST_UPDATE_TIME_FILE
        fi

	# Update device cycles
	#echo -n "CYCLES: "
	for dev in $(cat /tmp/mdt_devices)
	do
        	cycles=`esrv -sut localhost -get_dev_cycles $dev -ecg $MDT | awk -v dev=$dev '($1 == dev) {print $3}'`
	        if [ -z "$cycles" ]
        	then
                	cmd_fail_count=`expr $cmd_fail_count + 1`
			echo "CMD# esrv -sut localhost -get_dev_cycles $dev -ecg $MDT"
                	echo "devcycles command failed for dev = $dev. cmd_fail_count = $cmd_fail_count"
        	else
        		#echo -n "$dev = $cycles, "
        		echo $cycles > /tmp/shift/${dev}_cycles
        	fi
	done
	#echo

	# Check for any fails.
	fail=`esrv -sut localhost -get_fail_status -ecg $MDT | awk '/Fail_status/ {print $3}'`
        if [ -z "$fail" ]
        then
                cmd_fail_count=`expr $cmd_fail_count + 1`
		echo "CMD# esrv -sut localhost -get_fail_status -ecg $MDT"
                echo "failstatus command failed. cmd_fail_count = $cmd_fail_count"
		fail=0;
        fi

	if [ $fail -eq 1 ] 
	then
		echo "Fail Status = $fail"; echo
		sleep 60	# Sleep for 60 secs so that hang_monitor gets time to log error message in error log for HANGS.
		echo "ERROR: FAIL detected with below error." | tee $ERROR_LOG_FILE
		esrv -sut localhost -geterrlog -ecg $MDT | tee -a $ERROR_LOG_FILE
		echo "MDT = `cat $MDT_NAME_FILE`,  RUN_TIME = `cat $RUN_TIME_FILE` minutes,  LAST_UPDATE_TIME = `cat $LAST_UPDATE_TIME_FILE`" | tee -a $ERROR_LOG_FILE
		echo $ERROR > $STATUS_FILE
		/collect_shift_logs $ERROR
		terminate_stx
	fi

	# Display exerciser status and generate stats every 10 mins
	if [ $display_counter -eq 20 ] 
	then
        	echo "CMD#: esrv -sut localhost -status -ecg $MDT"; date
        	esrv -sut localhost -status -ecg $MDT; echo
		display_progress
		# Reset display counter.
		display_counter=0

		# Collect stats w/o it being displayed. /tmp/htxstats file should be updated here.
		esrv -sut localhost -getstats -ecg $MDT >/dev/null 2>&1
	fi

	# Display run status every minute
	[ `expr $display_counter % 2` -eq 0 -a $display_counter -ne 0 ] && display_progress

	# Sleep for 30 seconds before polling again.
	sleep 30
	display_counter=`expr $display_counter + 1`
done
