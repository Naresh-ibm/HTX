HXEHD README
============

GOAL:
====

Hxehd is an exerciser that aims at stress testing storage subsystem in particular and IO subsystem in general through block 
devices like direct/network attached storage, DVD RAM, USB attached storage by performing data integrity checks

SALIENT FEATURES:
=================

1. Supports direct/network attached storage devices, DVD RAM and USB attached storage
2. Supports various storage environments JBODs, RAID, SAN etc
3. Exerciser is generic enough to test any new device in above mentioned categories as long as OS device driver support is present.
3. Supports concurrent IO (helps varying SCSI adapter qdepth)
4. Supports random/sequential access types
5. Supports various intelligent data patterns to help isolate the cause of data corruption
6. Supports random size transfers upto 256K


HARDWARE DEVICES SUPPORTED:
==========================

IDE/SATA/SCSI/SAS Disks
DVD RAM
USB Flash drives

SUPPORTED OS:
============
AIX   : y
Linux : y
BML   : y

GENERAL INFO:
============

Hxehd exerciser tests writable storage devices. The exerciser program is an AIX/LINUX user application program and has a dependency
on OS device driver to perform operations on a storage device. Hxehd supports 32 bit LBA num and hence it can not test single disk
bigger than 2TB.


DESCRIPTION:
============

HTX disk exerciser is a multi threaded test program that performs data integrity tests(Write/read/compare) on device under test.
One copy of hxhed runs for each testable storage device on the system. Hence it is possible to concurrently exercise all disks 
of the system. It is capable of accessing any logical block on a disk. To avoid loss of data Hxehd doesn’t test disk that has a 
file system on it. The operations to be performed are specified in rule file, and can be modified using any text editor without 
having to change the exerciser. 

It is also possible to run two or more programs on the same physical disk by ensuring exclusive access of disk 
areas (non overlapping LBA range) to each program. Hxehd writes known pattern data on the disk before any other thread starts 
performing data integrity checks. This job is done by background thread (stanza no 1 in default rule file). The default pattern
is pattern #3. Refer Note 2 for more details about the pattern 3 format. The background stanza starts a thread that does a 256 KB 
write/read/compare operation that starts at the beginning of the disk and proceeds down  until the end of the disk.  It gets a 
two minute head start before several other threads are kicked off that run concurrently along with the background thread. These 
threads are aware of the LBA range that has already been covered by background stanza. Hence these threads run their test 
operations in the same range. They can as well perform read/compare operations because the data read from the disk can be compared 
against a known pattern.  Each thread performs specified disk operations in a loop as specified in the rule stanza. 

When thread detects a data anomaly, the exerciser drops to kernel debugger (if configured to do so) for further debug. On continuing
from kernel debugger exerciser does a reread into a separate buffer in memory. The exerciser then compares the reread buffer against 
what is expected. If a miscompare occurs again, then the data on the disk is likely to be bad and all three buffers will be saved. If 
no miscompare occurs on the reread then the data on the disk is likely to be good then only the write and the first read buffers are 
saved. This indicates some issue with the first read from a data integrity perspective.

Hxehd spawns a thread that monitors all the IO ops performed by other threads. Incase any operation takes longer than expected 
(configured through rule parameter HANG_TIME), this thread flags an error indicating a possible issue with an IO operation.


Running HXEHD on command line:
=============================
		
		The first argument passed to the program (argv[1]) is the device
		id e.g. "/dev/rhdisk0" , "/dev/rlv0hd0" , etc.

		The second argument passed to the program (argv[2]) is the
		Run Type e.g. "REG", or "EMC". Any other value passed will be
		intrepreted as running in "stand-alone" mode.

		The third argument passed to the program (argv[3]) is the rules
		file id. The rules are found in "/usr/lpp/htx/rules/reg/hxehd/xxxxxxxx" 
            or "/usr/lpp/htx/rules/emc/hxehd/xxxxxxxx". The file name "default" is 
            the default rules file to be run by HTX. To change which rules file is to be 
            run by HTX would require you to update the MDT file creatd by HTX.

	


SAMPLE DISK RULES FILE:
======================
Please refer to the default file in the rules file directory.


SAMPLE RULE:
===========

rule_id = SEQBWRC1
pattern_id = #003
addr_type = seq
num_oper = 0
oper = bwrc
type_length = fixed
num_blks = 512
starting_block = 0
direction = up
no_mallocs = 1
cpu_bind = no
loop_on_offset = yes
turn_attention_on = no
increment = 0
skip = -6

EXERCISER SPECIFIC LOG FILES:
============================
File name format of the buffers is "/tmp/<htx logname>.rbuf<n>", "/tmp/
<htx logname>.wbuf<n>, and "/tmp/<htx logname>.rerd<n>". Up to ten
buffers of each will be saved for each disk or logical volume.


UNDERSTANDING HTXSTATS:
======================

sdc:
  cycles                              =                  9   <----- Total number of complete rule file parses completed.
  # good reads                        =              5076276 <----- Total number of good reads
  # bytes read                        =       338506638848   <----- Total number of bytes read
  # good writes                       =              6150757 <----- Total number of good writes
  # total instructions                =                  0
  # bytes written                     =       864959630336   <----- Total number of bytes read
  # good others                       =                  0
  # bad others                        =                  0
  # bad reads                         =                  0
  # bad writes                        =                  0
  # data transfer rate(bytes_wrtn/s)  =        14506904.00   <----- (Avg)Number of bytes written in a second
  # data transfer rate(bytes_read/s)  =         5677355.00   <----- (Avg)Number of bytes read in a second
  # instruction throughput(MIPS)      =           0.000000


RULE FILE PARAMETERS:
====================

Rules File

     A rules file will consist of a number rules file stanzas. A rule stanza
     consists of rule keywords as described below grouped together. Each rule 
     stanza is seperated by a blank line.

Disk Rule Stanza Keywords 
  ___________________________________________________________________________
  |   Keyword           |    Value                |  Default Value          |
  |_____________________|_________________________|_________________________|
  |   ADDR_TYPE         |   SEQ                   |      RANDOM             |
  |                     |   RANDOM                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: If RANDOM, the random number generator nrand48() will be   |
  | used to generate the disk block(s) to be used for each operation. If    |
  | SEQ, the disk will will be addressed sequentially as specified by the   | 
  | STARTING_BLOCK, DIRECTION, INCREMENT, TYPE_LENGTH, and NUM_BLKS keywords|
  |_________________________________________________________________________| 
  |  COMMAND            |                         |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to input the command you want to run  |
  | from a shell. You type in the command in the format you want it to run. |
  | You do have some special characters that you can input into the command |
  | to get the device name. See NOTE 1.                                     |
  |_________________________________________________________________________| 
  |  CRASH_ON_ANYERR    |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: CRASH_ON_ANYERR = YES allows the exerciser to go into the  |
  | kernel debugger when any error occurs. Typing a "g" at the debugger     |
  | prompt will continue the exerciser. When the debugger is entered, the   |
  | following will be seen:                                                 |
  |     register 1 - the word DEADDEED                                      |
  |     register 2 - a loop number                                          |
  |     register 3 - a block number (LBA #)                                 |
  |     register 4 - pointer to the htx supervisor structure                |
  |     register 5 - pointer to the htx rules structure                     |
  | Once this keyword is used, then this setting will stay in effect until  |
  | you end the program or you reset this keyword in a later stanza.        |
  |_________________________________________________________________________|
  |  LA_ON_MIS          |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: LA_ON_MIS = YES allows the exerciser to trigger the logic  |
  | analyser attached to the SCSI bus in case of miscompare scenario.       |
  |_________________________________________________________________________| 
  |  CRASH_ON_MIS       |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: CRASH_ON_MIS = YES allows the exerciser to go into the     |
  | kernel debugger when a miscompare occurs. Typing a "g" at the debugger  |
  | prompt will continue the exerciser. When the debugger is entered, the   |
  | following will be seen:                                                 |
  |     register 3 - the word BEEFDEAD                                      |
  |     register 4 - a pointer to the write buffer                          |
  |     register 5 - a pointer to the read buffer                           |
  |     register 6 - offset into the buffer where the miscompare occurred   |
  |     register 7 - pointer to the device id                               |
  |     register 8 - pointer to the rule info                               |
  | Once this keyword is used, then this setting will stay in effect until  |
  | you end the program or you reset this keyword in a later stanza.        |
  |                                                                         |
  | HTX supports en environment variable HTXKDBLEVEL which determines       |
  | whether the exerciser will trap into KDB or not in case the exerciser   |
  | rules file does not specify CRASH_ON_MIS = YES. By default HTXKDBLEVEL  |
  | has been set to 1 which means evenif the exerciser rules file does not  |
  | specify CRASH_ON_MIS = YES, exerciser will trap into KDB on miscompare  |
  |_________________________________________________________________________|
  |   DEFAULT_PATTERN   |   #xxx                  |      #003               |
  |                     |   !xxx                  |                         |
  |                     |  HTX pattern            |                         |
  |                     |  library                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword specifies what bit pattern is to be used if   |
  | no pattern_id was specified in the rules stanza. Once set, the default  |
  | pattern will stay in effect until reset no matter how many stanzas are  |
  | to be run. This pattern is also used when the operation ends in a "w"   |
  | such as "wrcw". If the first character of the default pattern id is not |
  | #, the write buffer is filled using the bit pattern stored in the HTX   |
  | library; otherwise it is generated by the exerciser program as          |
  | described in NOTE 2.                                                    |
  |_________________________________________________________________________| 
  |  DEV_NAME           |                         |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to identify a changer device name so  |
  | that the exerciser can open the changer to be able to move media        |
  | within the device.                                                      |
  |_________________________________________________________________________| 
  |  DEBUG_PASSTHRU     |  YES                     | NO                     |
  |                     |  NO                      |                        |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to add some extra debug information   |
  | while using the pass-through interface for the cerify operations. Using |
  | this keyword will dump the CDB sent to the adapter in readable format   |
  | and some other extra information. Use this keyword only in conjunction  |
  | with the keyword PASS_THRU.
  |_________________________________________________________________________| 
  |  DIRECTION          |    UP                   |       UP                |
  |                     |    DOWN                 |                         |
  |                     |    IN                   |                         |
  |                     |    OUT                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This parameter specifies the direction for sequential      |
  | operations. UP is used to proceed from lowest to highest LBA. DOWN is   |
  | used to proceed from highest to lowest LBA. IN will pingpong from low   |
  | to high LBA while working its way to the middle LBA. OUT will pingpong  |
  | from low to high LBA while working its way from the middle. If the last |
  | LBA is encountered and the number of operations has not been reached,   |
  | it will then start over with the starting LBA number.                   |
  |_________________________________________________________________________| 
  |  GLOBAL_VAR         |                         |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword can update different global variables within  |
  | the program. See NOTE 3.                                                |
  |_________________________________________________________________________| 
  |  INCREMENT          |    n, -n                |       0                 |
  |-------------------------------------------------------------------------|
  | Explanation: Specify the number of blocks to skip between each          |
  | iteration of the operation during a sequential operation. This value    |
  | can be either a positive number or a negative number. If the value is   |
  | is a negative number then it CANNOT be greater than the number of       |
  | blocks specified. Ex. NUM_BLKS = 24, INCREMENT = -25 - NOT ALLOWED.     |
  |                       NUM_BLKS = 24, INCREMENT = -23 - ALLOWED          |
  |_________________________________________________________________________| 
  |  LOOP_ON_OFFSET     |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: For each iteration of an operation, a loop will be         |
  | performed that starts the read and write buffers at 0, 1, .. 63 byte    |
  | offsets into the buffer boundry.                                        |
  |_________________________________________________________________________| 
  |  MAX_BLKNO          |    n, .nn               |   highest LBA on media  |
  |-------------------------------------------------------------------------|
  | Explanation: This number is highest LBA number to be used during each   |
  | iteration of the operation. You can also set this number to a           |
  | percentage of the total number of blocks on the disk. Make sure that    |
  | if you use a percentage that it is greater than zero and less than one. | 
  | Ex. .75.                                                                |
  |_________________________________________________________________________| 
  |MAX_NUMBER_OF_THREADS|    2 - 8                |        2                |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword tells the exerciser the number of processes   |
  | that will be spun per stanza. This keyword can only be used with the    |
  | following operations: CARR, CARW, CAWW, and CAWR.                       |
  |_________________________________________________________________________| 
  |   MESSAGES          |    NO                   |      NO                 |
  |                     |    YES                  |                         |
  |                     |    DBUG                 |                         |
  |-------------------------------------------------------------------------|
  | Explanation: Specify whether the informational messages are to be put   |
  | to the HTX message log when HTX is running.                             |
  |_________________________________________________________________________| 
  |  MIN_BLKNO          |    n, .nn               |       0                 |
  |-------------------------------------------------------------------------|
  | Explanation: This number is lowest LBA number to be used during each    |
  | iteration of the operation. You can also set this number to a           |
  | percentage of the total number of blocks on the disk. Make sure that    |
  | if you use a percentage that it is greater than zero and less than one. | 
  | Ex. .25.                                                                |
  |_________________________________________________________________________| 
  |  NO_MALLOCS         |    1 - 100              |        2                |
  |-------------------------------------------------------------------------|
  | Explanation: Allocate the specified number of memory areas for the read |
  | and write buffers. If NO_MALLOCS = 10, 10 read buffers and 10 write     |
  | buffers will be allocated. After every 10 operations, these 20 buffers  |
  | will be freed, and 10 more each will again be allocated. The advantage  |
  | of this is to increase the number of start addresses for the buffers.   |
  |_________________________________________________________________________| 
  |  NUM_BLKS           |    1 - 512              |       1                 |
  |-------------------------------------------------------------------------|
  | Explanation: The number of blocks to be read / written during each      |
  | iteration of the operation.                                             |
  |_________________________________________________________________________|
  |   NUM_OPER          |    n                    |         1               |
  |-------------------------------------------------------------------------|
  | Explanation: Specify the number of operations to be performed by the    |
  | exerciser. If 0 is specified then the number of operations to do the    |
  | entire disk will be calculated.                                         | 
  |_________________________________________________________________________| 
  |  OFFSET             |    0 - 63               |        0                |
  |-------------------------------------------------------------------------|
  | Explanation: Start the read buffer, write buffer at the specified byte  |
  | (0 - 63) offset into a word boundry.                                    |
  |_________________________________________________________________________| 
  |  OM_INVERT          |        NO               |        NO               |
  |                     |        YES              |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser whether you wish|
  | flip the media when placing it into a slot in the changer.              |
  |_________________________________________________________________________| 
  |  OM_INVERT1         |        NO               |        NO               |
  |                     |        YES              |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser whether you wish|
  | flip the media when placing it into a slot in the changer.              |
  |_________________________________________________________________________| 
  |  OM_MAXSLOTS        |        n                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser what is the     |
  | maximum number of media slots that are available on this changer device.|
  |_________________________________________________________________________| 
  |  OM_PREVENT         |        NO               |        NO               |
  |                     |        YES              |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser not to remove   |
  | the media while it is being used in a drive.                            |
  |_________________________________________________________________________| 
  |  OM_SOURCE          |        n                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser what is the     |
  | id of the media you wish to move.                                       |
  |_________________________________________________________________________| 
  |  OM_TARGET          |        n                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser where you wish  |
  | to place the media.                                                     |
  |_________________________________________________________________________| 
  |  OM_TARGET1         |        n                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to tell the exerciser where you wish  |
  | to place the second media in an EXCHANGE MEDIA command.                 |
  |_________________________________________________________________________| 
  |   OPER              | R,     S,     W,        |         R               |
  |                     | RC,    RS,    RW,       |                         |
  |                     | WR,    WS,    WRC,      |                         |
  |                     | RWRC,  WRCW,  BWRC,     |                         |
  |                     | XCMD,  CARR,  CARW,     |                         |
  |                     | CAWR,  CAWW,  OMMV,     |                         |
  |                     | OMEX,  OMPRE, OMINF,    |                         |
  |                     | OMINI, OMINQ, OMINV,    |                         |
  |                     | W[M]R[N]C               |			    | 
  |-------------------------------------------------------------------------|
  | Explanation:   B = BackGround,    C = Compare,       R = Read,          |
  |                S = Sleep,         W = Write,        CA = Cache,         |
  |               EX = Exchange,     MV = Move Medium,  OM = Optical,       |
  |              INF = Information, INI = Initialization,                   |
  |              INQ = Inquiry,     INV = Inventory,   PRE = Prevent Removal|
  | This keyword is the operation to be performed. Ex. BWRC starts          |
  | a thread in the background that will write to the disk, read from the   |
  | disk, and then compare the write and read buffers to make of a match.   |
  | NOTE A: WRCW is a special operation. It does a write of the pattern you |
  |       specified, then does a read compare of the data, and then it will |
  |       clean up the area of the disk you were testing by writing the     |
  |       default pattern back out to the disk. For a better explanation of |
  |       default pattern see the DEFAULT_PATTERN keyword.                  |
  | NOTE B: The Cache operations are further defined in NOTE 4 near the end |
  |       of this document.  Please refer to that discussion.               |
  | NOTE C : Operation W[M]R[N]C will do M writes, N reads/compare operation|
  |          in one num_oper loop. This maintains read/write ratio for      |
  |          thread. Possible combinations : w[M]r[N]c, w[M], r[N]c, r[N],  |
  |           r[N]w[M], w[M]r[N].                                           | 
  | Examples : oper = w[2]r[5]c.  			                    |
  |_________________________________________________________________________|
  |  PAGE_ALIGN         |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used align the malloced buffers in the     |
  | program on a page boundry. Once this keyword is used, then this setting |
  | will stay in effect until you end the program or you reset this keyword |
  | in a later stanza.                                                      |
  |_________________________________________________________________________|
  |  PASS_THRU         |    YES                   |        NO               |
  |                    |    NO                    |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used instruct the exerciser to use the     |
  | read-verify (opcode 0x28), write-verify (0x2e) and verify (0x2f) options|
  | of the scsi pass through interface SCIOCMD.                             |
  |_________________________________________________________________________|
  |  ALIGN              |    >0                   |        2                |
  |                     |                         |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used align the malloced buffers in the     |
  | program on a boundry specified in the value. The value is specified in  |
  | bytes and is equal to the width of the SCSI bus in bytes. If patter_id  |
  | is specified as #007 then a positive value for align needs to be        |
  | specified. If not, then a default value of 2 is teken.                  |
  |_________________________________________________________________________|
  |  CPU_BIND           |    NO                   |        NO               |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to bind a cpu to the current thread   |
  |_________________________________________________________________________|    
  |   PATTERN_ID        |   #xxx                  |                         |
  |   PATTERN_ID        |   #xxx                  |                         |
  |                     |   !xxx                  |                         |
  |                     |  HTX pattern            |                         |
  |                     |  library                |                         |
  |-------------------------------------------------------------------------|
  | Explanation: The pattern id specifies what bit pattern is to be used.   |
  | If the first character of the pattern id is not #, the write buffer is  | 
  | filled using the bit pattern stored in the HTX pattern library; other-  |
  | wise it is generated by the exerciser program as described in NOTE 2.   |
  |_________________________________________________________________________| 
  |   RULE_ID           |   xxxxxxxx              |                         |
  |-------------------------------------------------------------------------|
  | Explanation: The rule id is used to identify the rule stanza being run  |
  | when putting out messages. It can contain any ASCII characters, it can  |
  | be 1 - 8 characters in length, and it MUST be specified in the stanza.  |
  | The RULE_ID must also contain a number defining what stanza it is.      |
  | This number is used by the HTX supervisor to determine what stanza is   |
  | being run. The program will not allow duplicate stanza numbers in the   |
  | rules file.                                                             |
  |_________________________________________________________________________| 
  |  RULE_OPTIONS       |                         |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword can invoke special options for stanza         |
  | processing. See NOTE 5.                                                 |
  |_________________________________________________________________________| 
  |  SCALE_OPER         |    n.n                  |        0.0              |
  |-------------------------------------------------------------------------|
  | Explanation: This number is a percentage value. It is used to determine |
  | the number of loops to be performed by a stanza. The calculation is done|
  | by multipling the SCALE_OPER value by the maximum number of blocks on   |
  | disk. Ex. You have a maximum number of blocks of 100,000 and a SCALE_   |
  | OPER of .10, then your number of operations would be 10,000.            |
  | NOTE: If the num_oper = 0 keyword is in the same stanza, then it will   | 
  | take precedence, otherwise the num_oper keyword is ignored.             |
  |_________________________________________________________________________| 
  |  SKIP               |    ()n               |        0                |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword is used to skip a stanza except when divided  |
  | evenly by the number. See NOTE 6.                                       |
  |_________________________________________________________________________| 
  |  SLEEP              |    n                    |        0                |
  |-------------------------------------------------------------------------|
  | Explanation: This number is number of microseconds the drive will be    |
  | turned off if the operation = S.                                        |
  |_________________________________________________________________________| 
  |   STARTING_BLOCK    |    n                    |      BOT                |
  |                     |    BOT                  |                         |
  |                     |    MID                  |                         |
  |                     |    TOP                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This parameter is required for sequential operations only. |
  | It can be an integer specifing an LBA number between 0 and the maximum  |
  | LBA on the disk being exercised. BOT, MID, and TOP are provided to      |
  | allow symbolic reference to the starting LBA number. BOT is always 0,   |
  | MID is the LBA that halfway between 0 and the maximum LBA, and TOP      |
  | refers to the maximum LBA number.                                       |
  |_________________________________________________________________________| 
  |  START_STANZA       |    NO                   |        YES              |
  |                     |    YES                  |                         |
  |-------------------------------------------------------------------------|
  | Explanation: This keyword tells the exerciser whether to start this     |
  | stanza or to read ahead other stanzas and then start them at the same   |
  | time (thread processing). The default is "YES" which means that each    |
  | stanza runs independently and the next will not start until the previous|
  | one finishes. If you want to run multiple stanzas then set this keyword |
  | to "NO" on each stanza until you get to the last stanza and the you set |
  | the keyword to "YES".
  |_________________________________________________________________________| 
  |   TYPE_LENGTH       |    FIXED                |      RANDOM             |
  |                     |    RANDOM               |                         |
  |-------------------------------------------------------------------------|
  | Explanation: Specify whether the data length is fixed or randomly       |
  | selected per stanza iteration. If RANDOM, the data length for each      |
  | operation will be generated using nrand48(). If FIXED, the data length  | 
  | will be the default blocksize * NUM_BLKS.                               |
  |_________________________________________________________________________| 
  |   UNIQUE_PATTERN    |    YES                |      NO                   |
  |                     |    NO                 |                           |
  |-------------------------------------------------------------------------|
  | Explanation: Use this keyword to generate the data pattern that are     |
  | unique for each test run. The patterns 3,4,5 etc. contain data that will|
  | remain unchanged across the devices for the same LBA number (Note that  |
  | the header portion will be different). But when trouble shooting certain|
  | type of problems, i.e. failures in the memory/cache subsystem and the   |
  | system side of the IO subsystem it would be nice to have a pattern that |
  | is unique to all tests running.  This would allow the data to indicate  |
  | its origin when looking at these types of problems. See the NOTE on     |
  | unique_patterns, to find an explanation for the header and the data     |
  | portions in case of unique_patterns.                                    |
  |_________________________________________________________________________|


NOTE 1:
-----------------------------------------------------------------------------
An example of a rules stanza showing a command is as follows:
           rule_id = NAME
           oper = xcmd
           command = iostat -d $d 5 5 >$o 2>&1
The "$" is a special delimiter for the commands. The meaning of which is in the
following list:
           $d = just the device name ( ex. hdisk1 )
           $D = just the raw device name ( ex. rhdisk1 )
           $p = fully qualified device name ( ex. /dev/hdisk1 )
           $P = fully qualified raw device name ( ex. /dev/rhdisk1 )
           $o = this is used to generate the error file for the command  
                ( ex. cmdout.hdisk1 )
In this case you would execute the command iostat against hdiskx with the
outputgoing to cmdout.hdisk?. Both the output and error information would go
to this file.


NOTE 2:
-----------------------------------------------------------------------------
If a pattern from the pattern library is to be used then a buffer is filled 
with data from the specified pattern. If the number of characters to be copied
into the buffer is greater than the size of the pattern file, the pattern
file data is repeated until the designated number of characters have been
copied. If the number of characters to be copied into the buffer is less than
size of the pattern file, the pattern file data is truncated to that size.


For PATTERN_ID #001 each 512 byte block has a 12 byte header (3 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  starting block number on disk
  4 - 9  random number seed
  10-11  16 bit random number
  and the remaining 125 words of each 512 byte block is formatted as follows:
  bytes description
  ----- ---------------------------------------------------
  0 - 1 relative word number e.g. 3,4,5,... 8,191 (0x1FFF)
  2      relative block number e.g. 0x01,0x02,...0x40
  3      relative block number e.g. 0x01,0x02,...0x40


For PATTERN_ID #002 each 512 byte block has a 12 byte header (3 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  starting block number on disk
  4 - 9  random number seed
  10-11  16 bit random number
  and the remaining 125 words of each 512 byte block is formatted as follows:
  bytes  description
  -----  ---------------------------------------------------
  0 - 1  relative word number e.g. 3,4,5,... 8,191 (0x1FFF)
  2 - 3  16 bit random number

The 16 bit random numbers and the random number seed are generated by the
exerciser program using the AIX random number generator function nrand48().
In case the disk data has been corrupted, the pattern can be reconstructed
using the random number seed.


For PATTERN_ID #003 each 512 byte block has a 48 byte header (12 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  LBA number on disk
  4 - 7  Time Stamp
  8 - 15 ASCII Device Name
 16 - 23 Stanza ID generating buffer
 24 - 33 ASCII Host Name
 34 - 39 Machine ID
 40 - 41 Pattern Algorithm in binary
 42 - 45 Buffer Signature ("MDHF")
 46 - 47 Checksum Value of header
 and the remaining 116 words of each 512 byte block is formatted as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 1  relative word number (ex. 0000, 0001, 0002, ...)
  2 - 3  recreateable pattern (ex. add the one to the starting LBA to get your
         pattern. 


For PATTERN_ID #004 each 512 byte block has a 48 byte header (12 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  LBA number on disk
  4 - 7  Time Stamp
  8 - 15 ASCII Device Name
 16 - 23 Stanza ID generating buffer
 24 - 33 ASCII Host Name
 34 - 39 Machine ID
 40 - 41 Pattern Algorithm in binary
 42 - 45 Buffer Signature ("MDHF")
 46 - 47 Checksum Value of header
 and the remaining 116 words of each 512 byte block is formatted as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 1  fixed pattern of A5A5.


For PATTERN_ID #005 each 512 byte block has a 48 byte header (12 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  LBA number on disk
  4 - 7  Time Stamp
  8 - 15 ASCII Device Name
 16 - 23 Stanza ID generating buffer
 24 - 33 ASCII Host Name
 34 - 39 Machine ID
 40 - 41 Pattern Algorithm in binary
 42 - 45 Buffer Signature ("MDHF")
 46 - 47 Checksum Value of header
 and the remaining 116 words of each 512 byte block is formatted as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 1  relative word number (ex. 0000, 0001, 0002, ...)
  2 - 3  fixed pattern of A5A5.
                     

For PATTERN_ID #007 each 512 byte block has a 48 byte header (12 words) as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 3  LBA number on disk
  4 - 7  Time Stamp
  8 - 15 ASCII Device Name
 16 - 23 Stanza ID generating buffer
 24 - 33 ASCII Host Name
 34 - 39 Machine ID
 40 - 41 Pattern Algorithm in binary
 42 - 45 Buffer Signature ("MDHF")
 46 - 47 Checksum Value of header
 and the remaining 116 words of each 512 byte block is formatted as follows:
  bytes  description
  -----  ------------------------------------------
  0 - 1  fixed pattern of FFFF.
  2 - 4  fixed pattern of 0000.


UNIQUE_PATTERNS

For unique_patterns, each 512 byte block is divided into 4 sub-blocks,
128 bytes each. And each sub-block contains a 48 byte header (12 words),
followed by 80 bytes of data. Hence each LBA contains 4 headers in case
of unique_patterns. The advantage of this approach is that in case of
cache-line issues, we will have atleast one header in the buffer which
will clearly indicate its origin.

The 48 bytes of header in each sub-block is filled up as follows:

  bytes  description
  -----  ------------------------------------------
  0 - 3  LBA number on disk
  4 - 7  Time Stamp
  8 - 15 ASCII Device Name
 16 - 23 Stanza ID generating buffer
 24 - 33 ASCII Host Name
 34 - 37 wbuf base address <---- !!!Differs here!!!
 38 - 39 0xa5a5            <---- !!!Differs here!!!
 40 - 41 Pattern Algorithm in binary
 42 - 45 Buffer Signature ("MDHF")
 46 - 47 Checksum Value of header

and the remaining 80 words of each 128 byte sub-block is formatted
as follows (completely different from all other patterns):
  bytes  description
  -----  ------------------------------------------
  0 - 1  algorithm
  2 - 3  Counter (Example 0x0001, 0x0002 ...).
  4 - 7  LBA  Counter. (recreatable pattern)
  8 - 15 Device name.


NOTE 3:
-----------------------------------------------------------------------------
The following two global variables can be changed using the GLOBAL_VAR;
   HANG_TIME - This variable takes an integer and it is the amount of time you 
               want the system to wait ( in seconds ) to check to see if
               any threads or hung.
   HANG_THRESHOLD - This variable is an integer and it is the number of times
                    you want the system to notify you of a thread being hung
                    before the system errors out.
   CRASH_ON_HANG - This variable takes either YES or NO as input. YES will 
                   put the system into the kernel debugger if a thread is
                   found to be hung. NO will put out messages in the both the
                   HTX message and error log that it found a hung thread.
                   Ex: global_var crash_on_hang = yes
   MISC_CMD - This allows a user to specify an AIX command to be run from a
              shell when a miscompare is found. This would happen before a
              crash of the system.
   RUN_ON_MISC - This variable tells the system their is an AIX command to be
                 run and to check the variable misc_run_cmd to find out what 
                 command to run.
   RUN_REREAD - This allows the user to not reread a the section of the disk
                that had reported a miscompare, if he doesn't want to.   
   MODE       - Default is VALIDATION, but can be changed to PERFORMANCE mode 
   		run exerciser generate maximum throughput. 
   		Maximum performance can be achieved by setting following rules 
   		parameters : 
   		pattern_id = HEX255. 
   		type_length = fixed. 
   		addr_type = seq. 
   		oper = wr .


NOTE 4:
-----------------------------------------------------------------------------
Cache Operations

Operations CARR, CAWW, CARW, and CAWR are designed to exercise the L1/L2
cache controllers.  They operate as follows:

* CAWR generates a write to the disk and simultaneously runs threads which read
  from the memory buffer being used for DMA.
* CAWW generates a write to the disk and simultaneously runs threads which write
  to the memory buffer being used for DMA.
* CARW generates a read from the disk and simultaneously runs threads which
  write to the memory buffer being used for DMA.
* CARR generates a read from the disk and simultaneously runs threads which
  read from the memory buffer being used for DMA.

The data threads that write into the memory buffer use the following algorithm:
  - The first thread writes the value 0x11 at offsets 0, 10, 20, 30, ... in the
    buffer,
  - The second thread writes the value 0x22 at offsets 1, 11, 21, 31, ... in
    the buffer,
  - and so on up to one less than the MAX_NUMBER_OF_THREADS attribute in the
    rule, that is, if MAX_NUMBER_OF_THREADS = 4 then there will be three data
    threads and one DMA thread.  The three data threads will write 0x11, 0x22,
    and 0x33 at offsets 0,1,2, 10,11,12, 20,21,22, and so on.

The CAWW operation will result in data on the disk that is the logical OR
between the pattern specified for the rule and the data written into the DMA
buffer by the threads.  Be sure to clean this up if later threads expect the
DEFAULT_PATTERN on the disk.

Also note that CARW can corrupt a disk block if it is running against a
logical volume and an LVM-initiated reassignment occurs while it is executing.
The reason is not obvious and is rather complicted.  Refer to CMVC defect
number 217637 in the aix family for details.


NOTE 5:
-----------------------------------------------------------------------------
The following rule options are defined:
  1. SAVE_SEEDS - this option is used in rules generating random LBAs.  The
     values used to seed the psuedo-random generator for block addresses and
     data lengths are saved.  They can be restored in a later stanza so that
     a sequence of addresses and block lengths can be recreated.  This option
     should only be used for stanzas with ADDR_TYPE = RANDOM.  There is only 
     one set of saved seeds, so every use of this option overwrites previously
     saved seed values.
  2. RESTORE_SEEDS - this option restores the last saved seed values.  Multiple
     stanzas with the restore option can occur, but restore is only allowed 
     if a previous stanza had the save option.
  3. SEEDS - this option will restore seeds used in a previous run. You can
     define what the seeds are and in this way you can recreate an error
     condition. The stanza that you want to recreate will have put out what
     seeds were used and type then in to recreate the pattern.
  4. TIMED - this option allow the user to see how long in seconds the stanza
     takes to finish. It also puts out the number of bytes processed in the 
     stanza and will put out a message showing the average bytes per second
     the stanza did in transfers during the stanza.

Notes on saving and restoring seeds:  When generating random block addresses,
it is possible (and likely) that a random sequence will overwrite the same LBA
more than once.  For this reason, it is not recommended that pattern #001,
#002, !001, or !002 be used when regenerating a sequence.  These patterns
generate different data each time they write an LBA range.  Thus if a seed X
was used to generate the sequence of LBAs for write, and then used to
regenerate a sequence of read/compares, miscompares can be expected because
some LBAs in the sequence may have been written more than once, each time with
different data.  The best procedure is to initialize the area of concern to
a known value such as HEXZEROS and then use pattern #003 to do the seeded
sequences.  Pattern #003 generates a sequence based on the LBA address and
is immune to the overwriting effects described above.

Also note that type_length values of RANDOM as well as FIXED are permissible.
When using FIXED lengths, the stanza where seeds are restored must have a
FIXED length also, and must be of equal or less length than the stanza where
seeds were saved.  The regenerated sequence will be based on the lengths
used when the seeds were saved, although the actual transfers in the
regenerated sequence will use the length specified in that stanza.


NOTE 6:
-----------------------------------------------------------------------------
If you set this value to a negative number, then you will run the stanza on
the first pass through the Rulefile and on every skip number of iterations
after the first time. Ex. - If you set it to -5, the stanza will run on the 
first pass and on every 5th iteration after the start of the exerciser.   
If you put a positive number then the stanza will only run on the skip value 
of iterations after the start of the exerciser. It will NOT run on the first
iteration of the exerciser. Ex. - If you set the value to 5, then the stanza
will only run on every fifth iteration of the rules file. There is one    
exception to this rule. If you set the SKIP value to a -1 then it will run
on every odd iteration of the rules file. If you set the SKIP value to a plus
1 then the stanza will run on every odd iteration of the rules except for the
first time through the rules file.

NOTE 7:
-----------------------------------------------------------------------------
hxehd support for UDO Drives:
                                                                                
hxehd has the support for Plasmon UDO drives. Plasmon UDO drives ( visible as
omdxx under AIX ) support 2 types of media ...
1) WORM ( Write Once Read Many ).
For this type of media, default.worm is the rules file associated.
                                                                                
2) RW ( Read/Write )
Since this media is similar to the magnetic disk, default rules file is
associated.

Appropriate support has been added in the HTX start-up media detection scripts
to detect the WORM against RW media and associate the correct rule file. This
feature is available and tested on AIX HTX only.
                                                                                
Media Caution:
Ensure that whenever any WORM or RW UDO media is placed in the UDO drive, the
media is formatted and ready-to-use.  HTX assumes that the UDO media is
formatted, and is BLANK.
                                                                                
Using un-formatted media or partially used media will result in HTX errors.

NOTE 8:
-----------------------------------------------------------------------------
hxehd supports DVD RAM drives.
For this type of drives default.dvd is the rules file associated.

Appropriate support has been added in the HTX start-up media detection scripts
to detect the media and associate the correct rule file.

SIGNAL 30 PROCESSING
      
To send a signal 30 to the exerciser you would to take option 11 from HTX. From
the command line type in "ps -ef" to find out the process id of the exerciser
you want to change. You would then issue the command "kill -30 pid". This 
causes a signal to be sent to the exerciser who will then catch the signal and 
will then reread the rules file. It will read the rules file that you started 
the HTX run with. Be sure to make your changes in this file before you send the
signal 30. Also, the exerciser will not process the new rules file until the
stanza it is currently on is finished.  


SAMPLE INFORMATIONAL MESSAGES:
=============================

/dev/rhdisk0          Apr 18 11:59:15 1988     err=00000000 sev=7    hxehd
hxehd /dev/rhdisk0 oth ../rules/reg/hxehd/default

/dev/rhdisk0       Apr 18 11:59:15 1988     err=00000000 sev=7    hxehd
             started SEQUP pat_lib_id = #001 
             addr_type = SEQ num_oper = 3 operation = R
             starting_block = BOT direction = UP increment = 2
             type_length = FIXED num_blks = 1

/dev/rhdisk0       Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             SEQUP loop=     1 blk=     0 len= 512

/dev/rhdisk0       Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             SEQUP loop=     2 blk=     2 len= 512

/dev/rdisk0        Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             SEQUP loop=     3 blk=     4 len= 512

/dev/rdisk0        Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             started SEQDOWN pat_lib_id = #001 
             addr_type = SEQ num_oper = 2 operation = R
             starting_block = TOP direction = DOWN increment = 1
             type_length = FIXED num_blks = 1

/dev/rdisk0        Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             SEQDOWN loop=     1 blk= 2399 len= 512

/dev/rdisk0        Apr 18 11:59:17 1988    err=00000000 sev=7    hxehd
             SEQDOWN loop=     2 blk= 2399 len= 512

     When running with HTX, detailed information messages showing
     loop, block number, and data length will be suppressed. See MESSAGES
     keyword.

Standard Message Header Format (first line)

  Device Id - Up to 14 characters
  Date/time
  Error Code - 8 hexadecimal digits
  Severity Code - 1 digit
  Program Name - hxehd
  Message Text - 219 characters


