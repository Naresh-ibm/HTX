* @(#)37      1.12.3.1 src/htx/usr/lpp/htx/rules/reg/hxetape/hxetape.readme, exer_tape, htxubuntu 6/16/10 05:03:38
*******************************************************************************
*   COMPONENT_NAME: EXER_TAPE
*
*   ORIGINS: 27
*******************************************************************************

Description

     This document describes the HTX tape hardware exerciser 'hxetape'.

General

     The exerciser program is written in 'C' to run on the RS6000
     as a normal AIX application program.

     It is invoked and run under control of the HTX (Hardware Test
     eXecutive) application. HTX may invoke single or multiple copies
     the exercisers, each running on a seperate device.

     The goal of the exerciser is to verify the operation of various
     types of tape devices running concurrently in different hardware
     configurations.

     The operations to be performed are specified in rules files and
     can be modified using any editor without having to change the exerciser
     program.

     There is one exerciser program for each tape device. Hence, it
     is possible to concurrently exercise all tape devices by using
     HTX control.

     Entries are created in the HTX Master Device Table (MDT) to cause as
     many exercisers to be initiated as desired (within reason).


Functional Specifications

Input

     The first argument passed to the program (argv[1]) is the device
     id e.g. "/dev/rmt0" , "/dev/rmt1" , etc.

     The second argument passed to the program (argv[2]) is the
     Run Type e.g. "REG", or "EMC". A value of "OTH", other, passed will
     be intrepreted as running in "stand-alone" mode.

     The third argument passed to the program (argv[3]) is the rules
     file name. In AIX 3.25 it is "/usr/lpp/htx/rules/reg/tape/xxxxxxx" or
     "/usr/lpp/htx/rules/emc/tape/xxxxxxx" and in AIX 4.1 the name is
     "/usr/lpp/htx/rules/reg/hxetape/xxxxxxxx" or
     "/usr/lpp/htx/rules/emc/hxetape/xxxxxxxx".

     An example of a rules file name would be 8mm5gb for the 8mm 5 gigabyte
     tape device.

Scratch Tape

     The exerciser requires that a scratch tape be loaded in the device.
     All the data on the tape will be destroyed.

     The exerciser will allow using a write protected tape, however, care
     should be taken in that the rules file is looking for a specific pattern
     of data and records when it performs reads and space operations.

Processing

     Start the exerciser, HTX or stand-alone.

     Sequentially read each rules file stanza and perform the operation(s)
     specified.

     Keep HTX informed as to the progress of the test and allow the HTX
     operator to stop the device if desired.

     If an error is detected, immediately inform HTX with an error message.

     After the last rules stanza has been completed, inform HTX of test end
     and start over with the first rules stanza, if not running stand-alone.

Outputs

     The outputs from the exerciser are in the form of information
     and error type messages. If running stand-alone, all informational
     messages will be written to stdout, and all error messages will be
     written to stderr. If initiated by HTX, informational messages will
     be suppressed, and error messages will be handled by HTX.

     The informational message has a severity code 7 or greater while
     error messages have a severity code of 6 or less. If the exerciser
     is initiated by HTX, all informational messages will be written to
     /tmp/htxmsg and all error messages will will be written to /tmp/htxerr.
     If the exerciser is being run in stand alone mode, OTH, all informational
     messages are written to stdout and all error messages are written to
     stderr.

Information Messages

     An information message usually contains two lines of information.
     The first line is formatted by HTX and contains the device name,
     time stamp, error number value (errno), the message severity, and
     the exerciser name. The remaining lines of information are formatted
     by the exerciser and contains various information relating to the
     currently active rule.

 Rule Start Message

     A typical Rule Started information message would be:

      /dev/rmt0         Nov  9 08:01:08 1993 err=00000000 sev=7 hxetape
      HXETAPE: CO-Close-Reopen Num_Ops: 1 Blocks: 1 Pattern: #001 Bytes: 512

 The field descriptions are:

  /dev/rmt0         Nov  9 08:01:08 1993 err=00000000 sev=7 hxetape
  1--------         2------------------- 3----------- 4---- 5------

   1 - device name
   2 - time stamp
   3 - errno value
   4 - message severity, value of 7 denotes information message.
   5 - exerciser name

  HXETAPE: CO - Close-Reopen  Num_Ops: 1  Blocks: 1  Pattern: #001  Bytes: 512
  1------  2-   3-----------  4---------  5--------  6------------  7---------

   1 - exerciser name.
   2 - rule's OPER keyword value.
   3 - rule function.
   4 - rule's NUM_OPER value, number of times to loop on this rule.
   5 - rule's NUM_BLKS value, number of blocksize blocks to process.
   6 - rule's data pattern id value.
   7 - number of bytes for this rule to process (NUM_BLKS * blocksize).

 Flow Information Message

     A typical Flow Information message would be:

      /dev/rmt1         Nov  9 08:01:07 1993 err=00000000 sev=7 hxetape
      Device type =  SCSI Tape Unit.   Blocksize = 1024.

 The field descriptions are:

  /dev/rmt1         Nov  9 08:01:07 1993 err=00000000 sev=7 hxetape
  1--------         2------------------- 3----------- 4---- 5------

   1 - device name
   2 - time stamp
   3 - errno value
   4 - message severity, value of 7 denotes information message.
   5 - exerciser name

  Device type =  SCSI Tape Unit.   Blocksize = 1024.
  1-------------------------------------------------

   1 - flow information message text describing a condition sensed or
       a function performed by the exerciser.

 Rule Information Message

     A typical Rule Information message would be:

  /dev/rmt1         Nov 29 11:03:12 1993 err=00000000 sev=7 hxetape
  REQSENSE :  Loop#: 1  Rule Blks: 0  File blks: 0  Bytes: 0  Pattern: #001
   Sense Data:
     00 700040000000000A0000000000040000
     10 00000000000000000000000000000000
     20 00000000000000000000000000000000

 The field descriptions are:

  /dev/rmt1         Nov 29 11:03:12 1993 err=00000000 sev=7 hxetape
  1--------         2------------------- 3----------- 4---- 5------

   1 - device name
   2 - time stamp
   3 - errno value
   4 - message severity, value of 7 denotes information message.
   5 - exerciser name

  REQSENS1 :  Loop#: 1  Rule Blks: 0  File blks: 0  Bytes: 0  Pattern: #001
  1-------    2-------  3-----------  4-----------  5-------  6------------

   1 - rule's RULE_ID value.
   2 - rule's current loop count value.
   3 - current number of blocks processed within the active rule.
   4 - relative block number position on tape in reference to the beginning
       of tape or the last file mark.
   5 - number of bytes for this rule to process (NUM_BLKS * blocksize).
   6 - rule's data pattern id value.

  Sense Data:
    00 700040000000000A0000000000040000
    10 00000000000000000000000000000000
    20 00000000000000000000000000000000
  1------------------------------------

   1 - sense data acquired from device with the request sense rule, RS.

 Error Messages

     An error message contains several lines of information.
     The first line is formatted by HTX and contains the device name,
     time stamp, error number value (errno), the message severity, and the
     exerciser name. The remaining lines of information are formatted by
     the exerciser and contain various information relating to the occuring
     error.

 Exerciser Error Message

     A typical Exerciser generated error message would be:

      /dev/rmt0         Dec  2 13:03:50 1992 err=00000005 sev=1 hxetape
      READ :  Loop#: 2983  Rule Blks: 298100  File blks: 298100  Bytes: 51200
      Pattern: #001
      Read error - I/O error.

 The field descriptions are:

  /dev/rmt0         Dec  2 13:03:50 1992 err=00000005 sev=1 hxetape
  1--------         2------------------- 3----------- 4---- 5------

   1 - device name
   2 - time stamp
   3 - errno value
   4 - message severity, value of 1 denotes HARD error message.
   5 - exerciser name

  READ1 :  Loop#: 2983  Rule Blks: 298100  File blks: 298100  Bytes: 51200
  1---     2----------  3----------------  4----------------  5-----------
    6------------
    Pattern: #001

   1 - rule's RULE_ID value.
   2 - rule's current loop count value.
   3 - current number of blocks processed within the active rule.
   4 - relative block number position on tape in reference to the beginning
       of tape or the last file mark.
   5 - number of bytes for this rule to process (NUM_BLKS * blocksize).
   6 - rule's data pattern id value.

  Read error - I/O error.
  1---------   2---------

   1 - exerciser's error description text.
   2 - system's error description text determined by using the
       errno value and looking up the corresponding error description
       in /usr/include/sys/errno.h.

 Exerciser Exit Error Message

  The exerciser may cause an exit() call if it senses certain errors.

  Currently the errors causing exit() calls are:

   exit() value   description
   ------------   -------------------------------------
        1         invalid number of passed arguments.
        2         invalid device name argument.
        3         unable to open rules file.
        4         invalid rules stanza.
        5         unable to open tape device.
        6         unsupported variable blocksize of zero.

  A typical message indicating an exerciser exit call would be:

   htx_messages      Nov 30 13:03:50 1993 err=00000000 sev=1 hxssup
   hxetape HE program for rmt1 terminated by exit(3) call.

 The field descriptions are:

  htx_messages      Nov 30 13:03:50 1993 err=00000000 sev=1 hxssup
  1-----------      2------------------- 3----------- 4---- 5------

   1 - type of message
   2 - time stamp
   3 - errno value
   4 - message severity, value of 1 denotes HARD error message.
   5 - program issuing message.

  hxetape HE program for rmt1 terminated by exit(3) call.
  1------ 2------------- 3--- 4------------ 5------ 6----

   1 - name of exerciser presenting exit condition.
   2 - standard message text.
   3 - active device when exit occurred.
   4 - standard message text.
   5 - exit() value issued by exerciser, in this case exit(3) means
       unable to open rules file.
   6 - standard message text.

 Read Compare Errors
    The exerciser can be requested to read and compare the data to a known
    pattern with the RC oper keyword. The known pattern data is placed in the
    write buffer to allow comparison with the read buffer data. If a miscompare
    of data is found, an error message is output in the htx message and error
    logs denoting the buffer position of the mis-compare. Also, HTX will dump
    the read and write buffer data in it's /tmp directory. These files are
    dumped as htxrmt1.rbuf1 and htxrmt1.wbuf1. The rmt1 reflects the device's
    name, such as rmt0, rmt1, rmt2. The rbuf1 and wbuf1 file extensions reflect
    the read and write buffer data respectively. Successive dump files would be
    named .rbuf2, .rbuf3, .rbuf4.

 A typical message indicating a mis-compare error would be:

  /dev/rmt1         Dec 20 12:30:12 1993 err=00000000 sev=1 hxetape
  READCOM1 : Loop#: 1 Rule Blks: 10 File blks: 10 Bytes: 10240 Pattern: HEXAA
  Miscompare at displacement (decimal) = 10
  wbuf = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  rbuf = 7171aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

 The field descriptions are:

  /dev/rmt1         Dec 20 12:30:12 1993 err=00000000 sev=1 hxetape
  1-----------      2------------------- 3----------- 4---- 5------

   1 - device name
   2 - time stamp
   3 - errno value
   4 - message severity, value of 1 denotes HARD error message.
   5 - program issuing message.

  READCOM1 : Loop#: 1 Rule Blks: 10 File blks: 10 Bytes: 10240 Pattern: HEXAA
  1-------   2------- 3------------ 4------------ 5----------- 6-------------

   1 - RULE_ID of active rule.
   2 - loop count for active rule.
   3 - number of blocks read in active rule.
   4 - number of blocks read in current file.
   5 - number of bytes for each read loop.
   6 - data pattern to use for compare of read data.

  The remaining information tells at what byte position the mis-compare
  was found and is followed by 20 hex bytes of data from the write and
  read buffers starting with the mis-compare bytes.

   Miscompare at displacement (decimal) = 10
   wbuf = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
   rbuf = 7171aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

   The first 30 bytes within the corresponding htxrmt1.rbuf1 and
   htxrmt1.wbuf1 files would contain the following data bytes translated
   to hex:

    decimal                        1 1
    position = 0 1 2 3 4 5 6 7 8 9 0 1
        wbuf = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
        rbuf = aaaaaaaaaaaaaaaaaaaa7171aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Operation
     Typically the exerciser is invoked from the HTX menu and will repeatedly
     read the rules file and perform the listed functions. You can also invoke
     the exerciser in a stand alone mode.

 HTX Invocation
     Under HTX , the exerciser is passed input parameters which specify the
     device name, run type, and rules file name. This information is
     automatically determined by HTX during login time. Refer to the
     'HTX User's Guide' in the section titled 'Customizing the mdt.all file'
     for information on how to view or alter this information.

     HTX will run the exerciser continuously until halted. During this time,
     the rules file is repeatedly read and the specified functions are
     performed on the device.

 HTX Standalone Mode
     The exerciser can be run in a stand alone mode by utilizing the
     heload command provided with HTX. The command heload will present a
     menu of the available hardware exercisers which can run.

     In stand alone mode, the exerciser will make only one pass through
     the rules file. Refer to the 'HTX User's Guide' in the section titled
     'Running HTX Exercisers in Standalone Mode' for more information about
     running in stand alone mode.

 Exerciser Functions
     The tape exerciser performs the following steps:

      a) Initialize signal termination handler.
      b) Verify passed arguments.
      c) Send HTX message stating exerciser starting.
      d) Open specified rules file.
      e) Obtain device's current blocksize from device driver information.
      f) Send HTX message stating device type and blocksize.
      g) Read rules from rules file and perform functions.

     The exerciser will perform steps a) through g) to complete a single
     pass in stand alone mode, or perform steps a) through f) and repeat
     step g) until stopped by HTX or halted due to an error with
     "halt on error" active.

     Refer to the 'HTX User's Guide' in the section titled 'HTX Main Menu'
     for more formation on continue/halt on error.

  VARIABLE BLOCK-SIZE OPERATIONS

     Most tape operations use a fixed-length block of 512 or 1024 bytes.
     However many tapes support a variable-length block.  This can be
     exercised with the VBS operations.

     When using VBS operations, the exerciser uses an IOCTL call to the
     driver to switch to variable block sizes.  This usually results in a
     rewind forced on the tape.

     The length of series of blocks written to the tape are generated from
     the psuedo-random number generator.  The seed for the random sequence
     can be explicitly specified or generated randomly by the program.  See
     the VBS_SEED rule description for syntax.  When a VBS stanza executes
     the seed value used will be echoed to the HTX message log (or stdout if
     running standalone).  If it is desired to create a rule file containing
     stanzas to regenerate the VBS sequence, then this output can be used
     to seed the random number generator so the lengths originally generated
     can be reproduced.
     You can also use a fixed length block size in this operation. You put in
     the keyword "FIXED" instead of "RANDOM" and you use "NUM_BLKS" to tell the
     exerciser what blocksize you want to use. Now it will use this blocksize
     for the length of the operation.

Rules
     Rules are a sequence of commands to set control parameters
     and to issue function commands to the device. Each rule is read in by
     the exerciser and decoded to determine which function is to be performed.
     The function may be a desired command to send to the device or it may be
     a value for a control parameter used by a function.

Rules Files
     The rules files are ascii files which contain sequences of rules keywords
     that determine functions to be performed on the device. A rule function
     begins with comments or keywords and ends with a blank line. The first
     rule in the rules file must be preceded with comments. In other words,
     no blank lines are allowed between the first rule and the top of the
     rules file. Comments in a rules file begin with an asterisk '*' in
     column 1.

     A blank line in a rules file signifies the end of a rule stanza
     and causes the active OPER function defined in the stanza to be executed.
     It is recommended that every rule stanza begin with unique rule_id to
     aid in locating the stanza if an error occurs. The exerciser interprets
     two blank lines as an end-of-file condition.

Rule Descriptions

  RULE_ID
     The RULE_ID is used within output messages to describe the active rule
     function. It can contain any ascii characters from 1 to 8 characters
     in length. This keyword and a value MUST be specified. The RULE_ID must
     also contain a number value. This number relates the HTX supervisor screen
     showing what rule stanza is running. The program will also not allow
     duplicate numbers in the rules file.

  PATTERN_ID
     The PATTERN_ID specifies what bit pattern is to be used for write and
     read compare functions.

     Normally, the write buffer is filled with a bit pattern from the
     the HTX pattern library at the location designated by the environment
     variable 'HTXPATTERNS'. An example of specifying a pattern in the rules
     file would be 'PATTERN_ID = HEXFF'.

     Some available pattern files are:

      ASCII     HEX55     HEXZEROS  HXPC5     HXPPAT1
      HEXAA     HXPA5     HXPDB6    HXPPAT2
      HEX255    HEXFF     HXPB5     HXPFFB    HXPPATH

     If the pattern file id starts with '#', the exerciser will generate a
     bit pattern to be used with write and compare operations. The valid
     pattern ids in this case are '#001' or '#002'. The bit patterns generated
     will be incrementing counts and block numbers or random number words.
     Each blocksize block of data written on tape will consist of a header
     followed by these incrementing values.

   Pattern ID #001

     Each Pattern #001 data write block has a 12 byte header followed by
     a 4 byte data group as shown below:

       HEADER:
       bytes     description
       -------   ------------------------------------------
        0 - 3    starting block number in current file.
        4 - 9    random number seed
       10 - 11   16 bit random number

      DATA GROUP:
       bytes     description
       -------   --------------------------------------------
       12 - 13   data group number within current write block
       14 - 15   (write block number x 0x0101) - (Note 1)

      Note 1: These bytes are the same throughout a single block of
      data and will change for succesive blocks. The bytes are determined
      by multiplying the number of the current write block within the buffer
      times a set value of 0x0101.

   Pattern ID #002

     Each Pattern #002 data write block has a 12 byte header followed by
     a 4 byte data group as shown below:

       HEADER:
        bytes     description
        -------   ------------------------------------------
         0 - 3    starting block number in current file.
         4 - 9    random number seed
        10 - 11   16 bit random number

       DATA GROUP:
        bytes     description
        -------   --------------------------------------------
        12 - 13   data group number within current write block
        14 - 15   16 bit random number

     The 16 bit random numbers and the random number seed are generated
     by the exerciser program using the AIX random number generation
     function 'erand48()'.
     In case the data has been corrupted, the pattern can be reconstructed
     using the random number seed.

  NUM_OPER

     This keyword defines the number of times to repeat the specified OPER
     function.

     For the variable block-size operations, it is valid to specify NUM_OPER
     equal to 0, which will cause the operation to be repeated until END-OF
     TAPE is encountered.

  OPER

     The various OPER functions are as follows:

      W - Writes sequential blocks to tape.
      R - Reads blocks from tape sequentially.
      RC - Reads blocks from tape and Compares the data to
           a specified pattern file.
      D - Issues the SCSI send diagnostics command and then reads the results.
          The returned values are checked and printed if any errors.
      RW - Rewind tape to beginning of tape.
      WEOF - Writes an End-of-File mark on tape. The NUM_BLKS parameter
             specifies how many marks to write. NUM_BLKS defaults to 1.
      S - Sleep or delay NUM_BLKS seconds before next function.
      E - Erase the remaining portion of the tape.
      SF - Skips forward or backward past NUM_BLKS end-of-file marks.
           A negative NUM_BLKS will skip backwards.
      SR - Skips forward or backward over NUM_BLKS records.
           A negative NUM_BLKS will skip backwards.
      CO - Closes and then reopens the device.
      WEOT - Writes in groups of (NUM_BLKS * blocksize) bytes of data until
             the end-of-tape is sensed.
      RCEOT - Reads in groups of (NUM_BLKS * blocksize) bytes of data until
              the end-of-tape is sensed.
      RS - Issues a Request Sense function, reads sense data and logs results.
      DBUG - Allow setting debug mode sampling in 4mm4gb devices.
      IE - Andante initialize element status.
      RES - Andante read element status.
      ML - Andante medium load.
      MUL - Andante medium unload.
      ASF - Andante skip forward or backward past NUM_BLKS end-of-file marks.
            A negative NUM_BLKS will skip backwards.
      ASR - Andante skip forward or backward over NUM_BLKS records.
            A negative NUM_BLKS will skip backwards.
      LB - Andante locate a block on tape.
      ADUL - Andante write to end-of-tape and then unload tape and continue
             to next tape till end of magazine.
      TWIE - Timberwolf initialize element.
      TWPE - Timberwolf position to element.
      TWRE - Timberwolf read element status.
      TWUL - Timberwolf write to end-of-tape and then unload tape and continue
             to next tape till end of magazine.
      WUL - Timberwolf write to end-of-tape and then unload tape.
      TWMM - Timberwolf move medium.
      HUNL - Hidalgo unload a tape and then reload a different tape.
      HINI - Hidalgo initialize element.
      HREL - Hidalgo read element status.
      HWUN - Hidalgo write to end-of-tape and then unload tape and continue
             till end of the magazine.
      CDRE - CDAT Wolf read element status.
      CDMM - CDAT Wolf move medium.
      VBSRD - Perform a variable block-size read.
      VBSWR - Perform a variable block-size write.
      XCMD - Perform a shell command from within the exerciser.

  NUM_BLKS

     This keyword is usually used to specify the number of data blocks
     to be read or written for each function. This value must be greater
     than zero and equal to or less than a run-time calculated maximum.  In
     earlier levels of the exerciser, the NUM_BLKS value multiplied by the
     device block size could not exceed 102400.  Later versions of the
     exerciser may change that restriction.

     The NUM_BLKS keyword is used with the W, R, RC, WEOF, S, SF, SR,
     WEOT, and RCEOT keywords. Refer to these keywords to determine it's use.

     For variable block-size operations (VBSRD and VBSWR), the NUM_BLKS
     keyword specifies the maximum size of the variable-length block in BYTES,
     not blocks.  The generated transfer will range from 1 to NUM_BLKS bytes.
     Note that if NUM_BLKS is set to the value 1, the maximum size of the
     transfer is set to the maximum size of the read/write buffer.  The default
     maximum is 102400 bytes but may be significantly larger if a fixed-length
     rule stanza in the file specifies a number of blocks that, when multiplied
     by the device block size, exceeds 102400 (see discussion above.)

  VBS_SEED
 
     This keyword is used to specify the random-number seed to use in the
     variable block-size operations.  This rule MUST be included on the first
     VBS stanza and is optional therafter.  If left out of a stanza, the
     VBS seed defaults to the last initialization used.  The VBS_SEED argument
     can be the keyword RANDOM, FIXED, or a list of three integers.


  CRASH_ON_MIS
 
     This keyword tells the exerciser to crash the system upon detection of a
     data miscompare.  When set to YES, the exerciser will cause a trap into
     the kernel debugger when a miscompare is detected.  Setting the value to
     NO disables this feature.  The default if this keyword is omitted is NO.
     Upon invoking the debugger, GPR3 will be set to the value 0xBEEFDEAD
     which allows the user to easily locate the values passed into the crash.
     GPR4 will hold the virtual address of the write buffer, GPR5 the read
     buffer, GPR6 the length of the write buffer, and GPR7 will hold a pointer
     to the device id. Enter the "g" command to the debugger to continue the  
     system.  Note that recovery is not guaranteed under this condition as the
     system has become unresponsive to attached devices while crashed. Also
     note that the debugger must be loaded via the bosboot command else 
     flashing 8s will result.
 
  UNLOAD_SLEEP

     This keyword tells the exerciser how long to sleep when running an
     Adante or Timberwolf medium changer when doing a sequential write
     and unload of each tape in the magazine.

  SOURCE_ID

     This keyword tells the exerciser where to find the tape to be moved
     in both the Adante and Timberwolf medium changers.

  DEST_ID

     This keyword tells the exerciser where to put the tape that is being
     moved in both the Adante and Timberwolf medium changers.

  CHS_FILE

     This keyword tells the exerciser what special file to open in diagnostic
     mode when using the Adante and Timberwolf medium changers.

  COMMAND

     This keyword is used to input the command you want to run from a shell. You
     type in the command in the format you want it to run. You have a special 
     character that you can input into the command to get the device name.
     The device name comes from the special filename that was an argument into
     the exerciser (ex. /dev/rmt0).
        $D = just the raw device name ( ex. rmt0 )
        $P = fully qualified raw device name ( ex. /dev/rmt0 )
        $o = this is used to generate the output file for the command  
             ( ex. cmdout.rmt0 ). 

  #CLOSE_PIPE

     This keyword is used when the user wants to try a new stanza or set
     crash_on_mis while the exerciser is running. This keyword keeps the
     "PIPE" open so that more than one stanza can be tried without stopping
     the exerciser.

  #CRASH_ON_MIS

     This keyword can be used to set crash_on_mis to on while the exerciser
     is running.

  #RULES_NAME
 
     This keyword can be used to change what rules file the exerciser is
     using while the exerciser is running.

Rules File

    The rules file determines what operations the exerciser program will
    perform. It will be stored in the HTX Rules file directory,
    ../rules/reg/hxetape/xxxxxxxx or ../rules/emc/hxetape/xxxxxxxx.

    A rules file will consist of a number of rules file stanzas as
    described below:

    Rule Stanza Keywords
    _____________________________________________________________________
    | Keyword       | Value(s) | Default    |Comments                    |
    |_______________|__________|____________|____________________________|
    | RULE_ID       |          |            |Required, text from 1 to    |
    |               |          |            |8 characters in length.     |
    |_______________|__________|____________|____________________________|
    | PATTERN_ID    | #001     | #001       |Data pattern to be used,    |
    |               | #002     |            |must be 8 characters or less|
    |_______________|__________|____________|____________________________|
    | NUM_OPER      | n        | 1          |Specify number of operations|
    |               |          |            |or times to perform the     |
    | See note 2    |          |            |current rule stanza.        |
    |_______________|__________|____________|____________________________|
    | OPER          |          | R          |Specify rule operation:     |
    |               | R        |            | R = Read.                  |
    |               | W        |            | W = Write.                 |
    |               | D        |            |D = Diagnostics command.    |
    |               | RC       |            |RC = Read/Compare data.     |
    |               | RW       |            |RW = Rewind.                |
    |               | WEOF     |            |WEOF = Write EOF mark.      |
    |               | S        |            |S = Sleep NUM_BLKS seconds. |
    |               | E        |            |E = Erase tape.             |
    |               | SF       |            |SF = Skip files.            |
    |               | SR       |            |SR = Skip Records.          |
    |               | WEOT     |            |WEOT = Write to rnf of tape.|
    |               | RCEOT    |            |RCEOT = Read/compare to end |
    |               |          |            |        of tape.            |
    |               | RS       |            |RS = Request Sense data.    |
    |               | CO       |            |CO = Close and Reopen.      |
    |               | VBSRD    |            |Variable Blocksize Read     |
    |               | VBSWR    |            |Variable Blocksize Write    |
    |_______________|__________|____________|____________________________|
    | NUM_BLKS      | n        | 1          |Number of blocks for the    |
    | see Notes 1,2 |          |            |current operation.          |
    |_______________|__________|____________|____________________________|
    | VBS_SEED      | RANDOM   | See note 2 |Seed for generating variable|
    |               | n, n, n  |            |variable length blocks      |
    |_______________|__________|____________|____________________________|
    | SOURCE_ID     | n        |            |Id of tape to move in medium|   
    |               |          |            |changer                     |
    |_______________|__________|____________|____________________________|
    | DEST_ID       | n        |            |Id of place to move tape in |
    |               |          |            |medium changer              |
    |_______________|__________|____________|____________________________|
    | CHS_FILE      |          |            |Name of special file to be  |
    |               |          |            |used when using diagnostics | 
    |               |          |            |in a medium changer         |
    |_______________|__________|____________|____________________________|
    | #CLOSE_PIPE   |          |            |Special keyword to keep a   |
    |               |          |            |"PIPE" open                 |
    |_______________|__________|____________|____________________________|
    | #CRASH_ON_MIS |          |            |Special keyword to set the  |
    |               |          |            |crash_on_mis var while HTX  |
    |               |          |            |is running                  |
    |_______________|__________|____________|____________________________|
    | #RULES_NAME   |          |            |Special keyword to change   |
    |               |          |            |which rules file is executed|
    |               |          |            |while HTX is running        |
    |_______________|__________|____________|____________________________|   

  Note 1: The NUM_BLKS keyword value has a limit of 1 to the maximum number
    of blocks that would fit into the data buffer. This maximum value is
    calculated from a set data buffer size of 102400 and the device
    information supplied blocksize value.
    The calculation is NUM_BLKS = buffer_size/blocksize. If the device
    information blocksize value is 1024, then the maximum number allowed
    would be 102400/1024 or 100.

  Note 2:
    See the previous description of this keyword for VBS considerations.


OPER Functions Table

    ________________________________________________________________________
    | OPER Function | Keywords Used  |Descriptions/default                  |
    |_______________|________________|______________________________________|
    | R - read      | NUM_BLKS       | number of data blocks / 1            |
    |_______________|________________|______________________________________|
    | W - write     | NUM_BLKS       | number of data blocks / 1            |
    |_______________|________________|______________________________________|
    | D - send/rcv  |                |                                      |
    |  diagnostics  |                |                                      |
    |_______________|________________|______________________________________|
    | RC - read and | NUM_BLKS       | number of data blocks / 1            |
    |  compare data |                |                                      |
    |               | PATTERN_ID     | data pattern used for compare        |
    |_______________|________________|______________________________________|
    | RW - rewind   |                |                                      |
    |_______________|________________|______________________________________|
    | WEOF - write  | NUM_BLKS       | number of file marks / 1             |
    | eof mark      |                |                                      |
    |_______________|________________|______________________________________|
    | S - sleep     | NUM_BLKS       | number of seconds / 1                |
    |_______________|________________|______________________________________|
    | E - erase to  |                |                                      |
    |  end of tape  |                |                                      |
    |_______________|________________|______________________________________|
    | SF - skip     |  NUM_BLKS      | number of files / 1                  |
    |  over files   |                |                                      |
    |_______________|________________|______________________________________|
    | SR - skip     |  NUM_BLKS      | number of records / 1                |
    |  over records |                |                                      |
    |_______________|________________|______________________________________|
    | CO - close /  |                |                                      |
    |  reopen device|                |                                      |
    |_______________|________________|______________________________________|
    | RS - request  |                |                                      |
    | sense data    |                |                                      |
    |_______________|________________|______________________________________|
    | WEOT - write  | PATTERN_ID     | data pattern used / #001             |
    | to end of tape| NUM_BLKS       | number of data blocks / 1            |
    |_______________|________________|______________________________________|
    | RCEOT -       | PATTERN_ID     | data pattern used for compare / #001 |
    |  read/compare | NUM_BLKS       | number of data blocks / 1            |
    | to end of tape|                |                                      |
    |_______________|________________|______________________________________|
    | VBSRD -       | NUM_BLKS       | number of data blocks / 1            |
    | variable block| PATTERN_ID     | data pattern used / #001             |
    | read test     | NUM_OPER       | number of times to do oper / 1       |
    |_______________|________________|______________________________________|
    | VBSWR -       | NUM_BLKS       | number of data blocks / 1            |
    | variable block| PATTERN_ID     | data pattern used / #001             |
    | write test    | NUM_OPER       | number of times to do oper / 1       |
    |_______________|________________|______________________________________|
    | DBUG - Debug  |                |                                      |
    | monitor mode  |                |                                      |
    |_______________|________________|______________________________________|
    | IE - Adante   |                |                                      |
    | init element  |                |                                      |
    |_______________|________________|______________________________________|
    | RES - Adante  | NUM_BLKS       | number of elements to read / 1       |
    | read element  |                |                                      |
    | status        |                |                                      |
    |_______________|________________|______________________________________|
    | ML - Adante   | SOURCE_ID      | id of tape slot to load              |
    | tape load     |                |                                      |
    |_______________|________________|______________________________________|
    | MUL - Adante  | SOURCE_ID      | id of slot to put tape               |
    | tape unload   |                |                                      |
    |_______________|________________|______________________________________|
    | ASF - Adante  | NUM_BLKS       | number of files / 1                  |
    | skip files    |                |                                      |
    |_______________|________________|______________________________________| 
    | ASR - Adante  | NUM_BLKS       | number of records / 1                |
    | skip records  |                |                                      |
    |_______________|________________|______________________________________| 
    | LB - Locate   | NUM_BLKS       | number of blocks / 1                 |
    | block on tape |                |                                      |
    |_______________|________________|______________________________________|
    | RP - Read     | NUM_BLKS       | number of files / 1                  |
    | position      |                |                                      |
    |_______________|________________|______________________________________| 
    | ADUL - Adante | NUM_BLKS       | number of block / 1                  |
    | write to EOT  | UNLOAD_SLEEP   | number of seconds to sleep           |
    | and unload    |                |                                      |
    |_______________|________________|______________________________________|
    | TWIE -        | CHS_FILE       | device special file name             |
    | Timberwolf    |                |                                      |
    | init element  |                |                                      |
    |_______________|________________|______________________________________|
    | TWPE -        | CHS_FILE       | device special file name             |
    | Timberwolf    | DEST_ID        | number of slot to position changer   |
    | position elem |                |                                      |
    |_______________|________________|______________________________________|
    | TWRE -        | CHS_FILE       | device special file name             |
    | Timberwolf    |                |                                      |
    | read element  |                |                                      |
    | status        |                |                                      |
    |_______________|________________|______________________________________|   
    | TWUL -        | CHS_FILE       | device special file name             |
    | Timberwolf    | NUM_BLKS       | number of blocks / 1                 |
    | write to EOT  | UNLOAD_SLEEP   | number of seconds to sleep           |
    | and unload    |                |                                      |
    |_______________|________________|______________________________________|
    | WUL -         | CHS_FILE       | device special file name             |
    | Timberwolf    | NUM_BLKS       | number of blocks / 1                 |
    | write & unload|                |                                      |
    |_______________|________________|______________________________________|
    | TWMM -        | CHS_FILE       | device special file name             |
    | Timberwolf    | SOURCE_ID      | number of slot to move tape to       |
    | move medium   | DEST_ID        | number of slot to get tape from      |
    |_______________|________________|______________________________________|


Sample Tape Rules File

   Please refer to the rule files in the tape rules file directory.

Note 3:
	Support for buster pattern
	--------------------------
	hxetape now recognizes buster pattern files whose name is in the 
	following format ...
	
	BSTR_XXX
	
	XXX stand for the bus width, hxetape needs to exercise. Ofcourse
	the buster pattern inside the file should comply with the bus 
	width reflected in the file name.
	
	For eg: BSTR_2 would mean this file contains buster pattern of 
	width 2 bytes. The pattern would then look something like this ...
	
	FFFF 0000 FFFF 0000 .... & so on.
	
	One can create a rule file using pattern_id as BSTR_2, and exercise
	it against hxetape. hxetape on seeing BSTR_2 as the pattern_id 
	would recognise this as a buster pattern file, and automatically
	align the pattern present in this file on a 2 byte boundry, so that
	the pattern appears aligned on the SCSI bus under stress.
	
	One can come up with any buster pattern file, say BSTR_4, BSTR_8 & 
	so on, having appropriate buster pattern data inside, and can simply
	specify the pattern file under the pattern_id keyword in the hxetape
	rule file, and thus can use hxetape for stressing the bus using the 
	specified buster pattern.
	
