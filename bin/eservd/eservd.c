/* IBM_PROLOG_BEGIN_TAG */
/* 
 * Copyright 2003,2016 IBM International Business Machines Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 		 http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* IBM_PROLOG_END_TAG */

#include "eservd.h"
#include "global.h"
#include "cfgclibdef.h"
#include <sys/resource.h>

#if defined(__OS400__)     /* 400 */
#include "popen.h"
#include "libos400.h"
#include <qshell.h>
#define system QzshSystem
#endif

#if !defined(__HTX_LINUX__)  && !defined(__OS400__)     /* 400 */
#define SEMCTL(x,y,z,a) (void)semctl(x,y,z,a)
#else
#define SEMCTL(x,y,z,a) semctl_arg.val=a, (void)semctl(x,y,z,semctl_arg)
#endif


/*
 ***  Externals ***************************************************************
 */

void exer_running_msg(int);
extern int rmv_ecg_all (char *mydev_id);
extern int send_err_msg(int fd, char *msg, int err_code);
extern int sem_length;
extern int init_syscfg();
extern int detach_syscfg();

/*
 ***  Global variables required for unexpected signal processing **************
 */

#ifdef _DR_HTX_
#include <sys/dr.h>
pid_t					DR_child_PID = 0;	 /* DR child process						  */
int					DR_key = 0xDEADBEEF; /* DR Key									  */
int 					semDR_id = -1;
#endif

/*****************************************************************************/
/*****  m a i n ( )  *********************************************************/
/*****************************************************************************/
/*                                                                           */
/* FUNCTION NAME =     main()                                                */
/*                                                                           */
/* DESCRIPTIVE NAME =  The main HTX function.                                */
/*                                                                           */
/* FUNCTION =          Invokes initialization functions, then calls          */
/*                     functions which run the system.                       */
/*                                                                           */
/* INPUT =             None - all input goes to lower level functions.       */
/*                                                                           */
/* OUTPUT =            None - all output generated by lower level functions. */
/*                                                                           */
/* NORMAL RETURN =     0 to indicate successful completion                   */
/*                                                                           */
/* ERROR RETURNS =     1 - Problem with build_ipc function                   */
/*                                                                           */
/* EXTERNAL REFERENCES                                                       */
/*                                                                           */
/*    OTHER ROUTINES = build_ipc - allocates and initializes HTX IPC         */
/*                         structures                                        */
/*                     end_it - sends SIGTERM to all hardware exerciser      */
/*                         programs, deletes HTX IPC structures, resets      */
/*                         display, ends program when all exercisers         */
/*                         terminate.                                        */
/*                     htx_profile - reads in HTX environment parameters     */
/*                     init_screen - initializes display for CURSES routines */
/*                                                                           */
/*****************************************************************************/

int
main (int argc, char *argv[])
{
    extern short	start_msg_hdl(int);
    extern int	mmenu(int);

  /*  variable definitions  **************************************************/
    char		work_dir[PATH_MAX + 1]; /* string for chdir command      */

  /*int		autostart;          auto-startup flag */
    int		rc = 0,i;            /* return code                       */
    int		daemon_PID;
    FILE		*pipe_id;
    int		user_autostart = 0;
    char		cmd[1024],buf[1024];

    DBTRACE(DBENTRY,("enter eservd.c main\n"));
  /*
   ***  beginning of executable code  *****************************************
   */

	print_log(LOGMSG,"First message \n");
	/*iexit(0);*/

#ifdef   SUPERUSER_ONLY
    if(getuid() != (uid_t) 0)  {
	fprintf(stderr, "HTX: %s process being executed by non-superuser, quitting... have a nice day !\n", argv[0]);
	print_log(LOGMSG,"HTX: %s process being executed by non-superuser, quitting ... havea nice day !\n", argv[0]);
	sleep(1);
	DBTRACE(DBEXIT,("exit(2) eservd.c main\n"));
	exit(2);
    }
#endif

#ifdef LIC_ENABLE
  rc = stx_license();
    if (rc != 0) {
       printf("Contact HTX Support to acquire a new HTX license key.\n");
       sleep(2);
       exit(4);
    }
#endif

    for (i=0; i<argc; i++) {
	print_log(LOGMSG,"argc = %d: argv[%d] = %s\n",argc,i,argv[i]);
	if ( strcmp(argv[i], "-auto") == 0 ) {
	    print_log(LOGMSG,"user wants autostart setup\n");
	    user_autostart = 1;
	    if ( argc > 2 ) {
		print_log(LOGMSG,"ecg name specified\n");
		strcpy(start_ecg_name, argv[++i]);
	    }
	}
    }

    if ( ( user_autostart != 1 ) && (argc > 2 )) {
	print_log(LOGERR,"Usage Error\n");
	DBTRACE(DBEXIT,("exit(0)a eservd.c main\n"));
	exit(0);
    }

    if ((argc == 2) && ((strcmp(argv[1],"-shutdown")) ==0)) {
	print_log(LOGMSG,"eservd shutdwon requested...This pid = %d\n", getpid());
	sprintf(msg_type,"STOP");
	system_call = TRUE;
	system("/usr/lpp/htx/bin/esrv -sut localhost -stoptest");
	system_call = FALSE;
     /* send a SIGKILL to all eservds remaining */
	sprintf(cmd,"ps -ef | grep eservd | grep -v shutdown| grep -v %d |grep -v grep | grep -v vi| awk \'{print $2}\'|xargs kill -9 >/dev/null 2>&1",getpid());
	system_call = TRUE;
	system(cmd);
	system_call = FALSE;
	//closelog();
	//send_broadcast("SHUTDOWN", "some time", "some time", 0);
	print_log(LOGMSG,"Exiting ... \n");
	DBTRACE(DBEXIT,("exit(0)b eservd.c main\n"));
	exit(0);
    }

    system_call = TRUE;
    rc = system("test `ps -ef | grep eservd | grep -v \"grep eservd\" | "
		"grep -v \"dbx eservd\" |wc -l` -gt 1");
	system_call = FALSE;
    if (rc == 0)                         /* More than 1 eservd?               */
    {
	(void) fprintf(stderr,"\nMore than one copy of eservd running...\n"
		       "This copy exiting...\n");
	(void) fflush(stderr);
	DBTRACE(DBEXIT,("exit(1) eservd.c main\n"));
	exit(1);
    } /* endif */

#if !defined(__HTX_LINUX__) && !defined(__OS400__)
    system_call = TRUE;
    system("errlogger --- STX Started ---");
    system_call = FALSE;
#endif
    system_call = TRUE;
    system("date +\"STX Daemon was started on %x at %X %Z\">>/tmp/stx.start.stop.time");
    system_call = FALSE;


#if defined(__OS400__)
    daemon_PID = 0; /* os400 fork(); */
#else
    daemon_PID = fork();
#endif

    switch(daemon_PID) {

	case 0:


	(void) setpgrp();
#if !defined(__OS400__)
	    (void) setpriority(PRIO_PROCESS, 0, -1);
#endif

  /* Make sure that we're the only copy of eservd running... */
  /* get HTXPATH environment variable ***************************************/
#if defined(__HTX_LINUX__) || defined(__OS400__)  /* 400 */
	    program_name = basename(argv[0]);

	    if (htx_strlen(htx_strcpy(HTXPATH, getenv("HTXPATH"))) == 0)
		(void) htx_strcpy(HTXPATH, "/usr/lpp/htx");
#else
	    program_name = argv[0];              /*  setup program_name variable.     */
	    if (strlen(argv[0]) >9)
		program_name = argv[0]+17;  /*  setup program_name variable.*/

	    if ((int) htx_strlen((char *) strcpy(HTXPATH, getenv("HTXPATH"))) == 0)
		(void) htx_strcpy(HTXPATH, "/usr/lpp/htx");
#endif

	    setbuf(stdout, obuf);              /*    dedicate static buffer to stdout */
	    print_log(LOGMSG,"copied program name = %s\n",program_name); fflush(stdout);
#if defined(__HTX_LINUX__) || defined(__OS400__)  /* 400 */
	    htx_strcpy(save_dir,"/usr/lpp/htx");
#else
	    (void) getwd(save_dir);       /*  get current directory                    */
#endif
	    (void) htx_strncpy(work_dir, HTXPATH, PATH_MAX + 1);
	    (void) strncat(work_dir, "/bin", PATH_MAX + 1);
	    (void) chdir(work_dir);       /*  change current directory                 */

	    htx_profile(&autostart);      /*  process profile                          */
		rc = init_syscfg();           /* initialize syscfg*/
		if (rc != 0) {
			printf("Error: init_syscfg  failed with error code <%d>, exiting...\n", rc);
		}
		
	    if ( user_autostart == 1) {
		print_log(LOGMSG,"user has forced the autostart option\n");
		autostart = 1;
	    }

#ifdef _DR_HTX_
	    if (start_DR_child() != 0)
		(void) send_message("DR child fork error", 0, HTX_SYS_HARD_ERROR, HTX_SYS_MSG);
#endif

	    get_htx_level();
	    print_log(LOGMSG,"level = %s HTXPATH = %s\n", level_str, HTXPATH);
	    fflush(stdout);

	    setup_server();
	    print_log(LOGMSG,"****Returned from server*****\n");
	    fflush(stdout);

	    print_log(LOGMSG,"Shutting down the daemon\n");
	    fflush(stdout);
	    sig_end_flag=1;
	    end_it(0);    /* normal shutdown */

	    print_log(LOGMSG,"Done: Shutting down the daemon\n"); fflush(stdout);
	    DBTRACE(DBEXIT,("exit(0)c eservd.c main\n"));
	    exit(0);

	default:
	    print_log(LOGMSG,"Parent will exit\n child pid: %d",daemon_PID);
	    DBTRACE(DBEXIT,("exit(0)d eservd.c main\n"));
	    exit(0);

    }


    end_it(0); /* normal shutdown */

    DBTRACE(DBEXIT,("return eservd.c main\n"));
    return(0);                           /* this statement only for lint      */
} /* main() */

/*****************************************************************************/
/*****  start_DR_child	******************************************************/
/*****************************************************************************/

#ifdef _DR_HTX_
void   DR_child_handler(int sig, int code, struct sigcontext *scp)
{
    char msg_text[512];
    struct semid_ds   semids;
    dr_info_t         DRinfo;
    int rc = 0;
    int semval = 0;
    DBTRACE(DBENTRY,("enter eservd.c DR_child_handler\n"));

    strcpy(msg_text,"DR_child_handler: entered SIGRECONFIG handler");
    (void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);

    do {
	rc = dr_reconfig(DR_QUERY, &DRinfo);
    } while ((rc < 0) && (errno == 4));

    if (rc < 0) {
	sprintf(msg_text,"DR_child_handler: dr_reconfig call failed..errno(%d) (%s)", errno,strerror(errno));
	(void) send_message(msg_text, errno, HTX_SYS_HARD_ERROR, HTX_SYS_MSG);
	DBTRACE(DBEXIT,("return/a eservd.c DR_child_handler\n"));
	return;
    }

    sprintf(msg_text,"DR_child_handler: dr_reconfig output:\
	 pre:%d, check:%d, doit:%d, post:%d, posterror:%d,\
	 add: %d, rem:%d, cpu:%d, mem:%d, lcpu:%d, bcpu:%d\n",
	    DRinfo.pre, DRinfo.check, DRinfo.doit, DRinfo.post, DRinfo.posterror,
	    DRinfo.add, DRinfo.rem, DRinfo.cpu, DRinfo.mem, DRinfo.lcpu, DRinfo.bcpu);
    (void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);

    if (DRinfo.check == 1)
    {
	semval = semctl(semDR_id, 0, GETVAL, &semids);

	if (semval == 1) {
	    sprintf(msg_text,"DR_child_handler: another DR operation before exer restart\n");
	    strcat(msg_text,"FAILING DR operation\n");
	    (void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);
	    dr_reconfig(DR_EVENT_FAIL, &DRinfo);
	}

    }

    DBTRACE(DBEXIT,("return/b eservd.c DR_child_handler\n"));
    return;
}

int start_DR_child(void)
{
    int semval = 0, i = 0;
    char msg_text[512];
    struct sigaction sigvector;
    DBTRACE(DBENTRY,("enter eservd.c start_DR_child\n"));

    semDR_id = semget(DR_key, 1, IPC_CREAT | S_IRUSR | S_IWUSR | S_IRGRP |
		      S_IWGRP | S_IROTH | S_IWOTH);
    if (semDR_id == -1) {
	strcpy(msg_text,"Unable to get the DR semaphore...No point forking DR child\n");
	(void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);
	return -1;
    }

    SEMCTL(semDR_id, 0, SETVAL, 0);

    DR_child_PID = fork();

    if (DR_child_PID == 0)
    {
	strcpy(msg_text,"Inside DR child...will wait here\n");
	(void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);

	sigemptyset(&(sigvector.sa_mask));
	sigvector.sa_flags = 0;
	sigvector.sa_handler = SIG_DFL;

	for (i = 1; i <= SIGMAX; i++)
	    (void) sigaction(i, &sigvector, (struct sigaction *) NULL);

	sigemptyset(&(sigvector.sa_mask));
	sigvector.sa_flags = 0;
	sigvector.sa_handler = (void (*)(int))DR_child_handler;
	(void) sigaction(SIGRECONFIG, &sigvector, (struct sigaction *) NULL);

	(void) setpgrp();

	DBTRACE(DBEXIT,("hang/exit(0) eservd.c start_DR_child\n"));
	while(1);

	exit(0);
    }
    else if (DR_child_PID > 0)
    {
	sprintf(msg_text,"DR child started..pid(%d)\n", DR_child_PID);
	(void) send_message(msg_text, 0, HTX_SYS_INFO, HTX_SYS_MSG);
	DBTRACE(DBEXIT,("return 0 eservd.c start_DR_child\n"));
	return 0;
    }
    else
    {
	DBTRACE(DBEXIT,("return -1 eservd.c start_DR_child\n"));
	return -1;
    }
}
#endif



/*****************************************************************************/
/*****  e n d _ i t ( )  *****************************************************/
/*****************************************************************************/
/*                                                                           */
/* FUNCTION NAME =     end_it()                                              */
/*                                                                           */
/* DESCRIPTIVE NAME =  Ends the HTX programs                                 */
/*                                                                           */
/* FUNCTION =          Sends SIGTERM to all hardware exerciser programs,     */
/*                     deletes HTX IPC structures, resets display, and ends  */
/*                     HTX supervisor program when all exercisers terminate. */
/*                                                                           */
/* INPUT =             exit_code - value to be used with the exit() system   */
/*                         call                                              */
/*                     fast_flag - f = fast shutdown; s = slow (old) shutd.  */
/*                                                                           */
/* OUTPUT =            SIGTERM to all hardware exerciser programs            */
/*                         exerciser programs                                */
/*                     IPC delete requests                                   */
/*                     exit_code value passed to operating system upon end   */
/*                                                                           */
/* NORMAL RETURN =     0 to indicate successful completion                   */
/*                                                                           */
/* ERROR RETURNS =     1 - problem with build_ipc function                   */
/*                     0x80 | signal number - program stopped due to signal  */
/*                                                                           */
/* EXTERNAL REFERENCES                                                       */
/*    OTHER ROUTINES = child_death - handles SIGCLD signal                   */
/*                     send_message - sends messages to msg handler program  */
/*                                                                           */
/*    DATA AREAS =     MSGLOGKEY message queue (identified by the msgqid     */
/*                        variable)                                          */
/*                     SHMKEY shared memory segment (this segment is pointed */
/*                        to by the shm_addr pointer)                        */
/*                     SEMHEKEY semaphores (identified by the semhe_id       */
/*                        variable)                                          */
/*                                                                           */
/*    MACROS =         PRTMSG - Print message CURSES macro                   */
/*                              (defined in common/hxiconv.h)                */
/*                                                                           */
/*****************************************************************************/

void end_it(int exit_code)
{
  /*
   ***  variable/function declarations  **************************************
   */
  int rc_ipc;                          /* Return code from ipc calles       */
  struct sigaction    sigvector;       /* structure for signals */
  DBTRACE(DBENTRY,("enter eservd.c end_it\n"));

  /*
   ***  beginning of executable code  *****************************************
   */

  print_log(LOGMSG,"in end_it\n"); fflush(stdout);

      /*
       ***  cancel SIGCLD signal processing  **********************************
       */
  if(sig_handle_done) {
    sigvector.sa_handler = SIG_IGN;
    sigvector.sa_flags = 0;         /* do not restart system calls on sigs */
    (void) sigaction(SIGCHLD, &sigvector, (struct sigaction *) NULL);
    sig_handle_done = 0;
  }
  print_log(LOGMSG,"Cancelled sigchld..."); fflush(stdout);
      /*
       ***  send SIGTERM signals  *********************************************
       */
      /***  HE's  ************************************************************/

      /***   program  *********************************************/
  if (hxstats_PID != 0)
  {
    (void) kill(hxstats_PID, SIGTERM);
  } /* endif */
  print_log(LOGMSG,"hxstats_pid..."); fflush(stdout);
  if (hang_mon_PID != 0) {
    kill(hang_mon_PID, SIGTERM);
    print_log(LOGMSG,"doing hang_mon_PID...%d pid=%d",hang_mon_PID,getpid()); fflush(stdout);
  //waitpid(hang_mon_PID,(void *)0, 0);
  }  /* endif */
  print_log(LOGMSG,"hang_mon_pid..."); fflush(stdout);
  if (equaliser_PID != 0) {
	  kill(equaliser_PID, SIGTERM);
  }

  print_log(LOGMSG,"Shutting down DR..."); fflush(stdout);
#ifdef _DR_HTX_
  if (DR_child_PID != 0)
    (void) kill(DR_child_PID, SIGTERM);
#endif
  print_log(LOGMSG,"Done Shutting down DR..."); fflush(stdout);

  /* Make sure that all the child processes of eservd are killed */
  while (1) {
#ifdef _DR_HTX_
   if( hxstats_PID == 0 && hang_mon_PID == 0 && DR_child_PID == 0 ) {
    break;
   }
#else
   if( hxstats_PID == 0 && hang_mon_PID == 0 ) {
     break;
   }
#endif
   sleep(1);
  }

  /***  message handler  *************************************************/
  sigvector.sa_handler = SIG_IGN;  /* Ignore SIGCHLD signal              */
  (void) sigaction(SIGCHLD, &sigvector, (struct sigaction *) NULL);

  /***************************************************************************/
  /**  get rid of all IPC structures  ****************************************/
  /***************************************************************************/

  if (semot_id != -1) {
    rc_ipc = semctl(semot_id, (int) NULL, IPC_RMID, (struct semid_ds *) NULL);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in semctl call for semot_id= %d(0x%x) in end_it. Errno = %d (%s)\n", semot_id, semot_id, errno, strerror(errno));
    else
      print_log(LOGMSG,"Done removing semot_id = %d %x\n",semot_id, semot_id);
  }
  /*  get rid of shared memory structure  */
  if (shm_id != -1) {
    rc_ipc = shmdt(ecg_info[0].exer_list);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in shmdt call for ecg_info= %d(0x%x) in end_it. Errno = %d (%s)\n", (int)ecg_info, (int)ecg_info, errno, (char*)strerror(errno));
    else
      print_log(LOGMSG,"Done detaching ecg_info = %d %x\n",(int)ecg_info, (int)ecg_info);
    rc_ipc = shmctl(shm_id, IPC_RMID, (struct shmid_ds *) NULL);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in shmctl call for shm_id= %d(0x%x) in end_it. Errno = %d (%s)\n", shm_id, shm_id, errno, strerror(errno));
    else
      print_log(LOGMSG,"Done removing shm_id = %d %x\n",shm_id, shm_id);
    shm_addr.hdr_addr = 0;
    shm_id = -1;
  }

  if (info_send.scn_num.scn_all_info != NULL) {
    free(info_send.scn_num.scn_all_info);
    info_send.scn_num.scn_all_info = NULL;
  }
  if ( ecg_info != NULL ) {
    free(ecg_info);
    ecg_info=0;
  }
  if ( dup_info != 0 ) {
    free(dup_info);
    dup_info = 0;
  }

  if ( rem_shm_addr != NULL && rem_shm_addr->cur_shm_addr != NULL ) {
    free(rem_shm_addr->cur_shm_addr);
    rem_shm_addr->cur_shm_addr = 0;
  }
  if (rem_shm_id != -1) {
    rc_ipc = shmdt(rem_shm_addr->sock_hdr_addr);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in shmdt call for rem_shm_addr->sock_hdr_addr= %d(0x%x) in end_it. Errno = %d (%s)\n", (int)rem_shm_addr->sock_hdr_addr, (int)rem_shm_addr->sock_hdr_addr, errno, (char*)strerror(errno));
    else
      print_log(LOGMSG,"Done detaching rem_shm_addr->sock_hdr_addr = %d %x...",(int)rem_shm_addr->sock_hdr_addr, (int)rem_shm_addr->sock_hdr_addr);

    rc_ipc = shmctl(rem_shm_id, IPC_RMID, (struct shmid_ds *) NULL);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in shmctl call for rem_shm_id= %d(0x%x) in end_it. Errno = %d (%s)\n", rem_shm_id, rem_shm_id, errno, strerror(errno));
    else
      print_log(LOGMSG,"Done removing rem_shm_id = %d %x...",rem_shm_id, rem_shm_id);
    rem_shm_id = -1;
  }
  if (rem_shm_addr != NULL ) {
    free( rem_shm_addr);
    rem_shm_addr = 0;
  }

#ifdef _DR_HTX_
  if (semDR_id != -1) {
    rc_ipc = semctl(semDR_id, (int) NULL, IPC_RMID, (struct semid_ds *) NULL);
    if (rc_ipc == -1)
      print_log(LOGERR,"Error in semctl call for semDR_id= %d(0x%x) in end_it. Errno = %d (%s)\n", semDR_id, semDR_id, errno, strerror(errno));
    else
      print_log(LOGMSG,"Done removing semDR_id = %d %x...",semDR_id, semDR_id);
  }
#endif

  /***************************************************************************/
  /**  clear screen and end CURSES support  **********************************/
  /***************************************************************************/

  /***************************************************************************/
  /**  exit program  *********************************************************/
  /***************************************************************************/
  print_log(LOGMSG,"Done: resetting term\n");
  fflush(stdout);
     /*if (start_msg_done) {
       print_log(LOGMSG,"Stopping the hxsmsg\n"); fflush(stdout);
       send_message("eServer Daemon: This is the final system message.", 0, HTX_SYS_INFO, HTX_SYS_FINAL_MSG);
       start_msg_done = 0;
     }*/
  if (start_msg_done) {
    send_message("eServer Daemon: This is the final system message.", 0, HTX_SYS_INFO, HTX_SYS_FINAL_MSG);
    start_msg_done = 0;
  }

  rc_ipc = detach_syscfg();
  if(rc_ipc != 0) {
    print_log("Error: delete_syscfg return with error code <%d>", rc_ipc);
  }

  system_call = TRUE;
  print_log(LOGMSG, "Calling cleanup scripts");
  system("/usr/lpp/htx/etc/scripts/stx.cleanup");
  system_call = FALSE;
  if (sig_end_flag) {
    print_log(LOGMSG, "Exiting...");
    DBTRACE(DBEXIT,("exit(0) eservd.c end_it\n"));
    exit(0);
  }
  else {
    print_log(LOGMSG, "returning from end_it");
    DBTRACE(DBEXIT,("return eservd.c end_it\n"));
    return;                              /*  this statement only for lint     */
}
    print_log(LOGMSG,"cleanup all the remaining exercisers\n");fflush(stdout);
  /* system_call = TRUE;
     system("ps -ef|grep hxe|awk '{print $2}'|xargs kill -15 >/dev/null 2>&1");
     system_call = FALSE;
     sleep(5); */
  system_call = TRUE;
  system("ps -ef|grep hxe|awk '{print $2}'|xargs kill -9 >/dev/null 2>&1");
  system_call = FALSE;
  system_call = TRUE;
  system("ps -ef|grep sct2|awk '{print $2}'|xargs kill -9 >/dev/null 2>&1");
  system_call = FALSE;

  DBTRACE(DBEXIT,("return eservd.c end_it\n"));
  return;                              /*  this statement only for lint     */
} /* end_it() */



/*****************************************************************************/
/*****  h t x _ p r o f i l e ( )  *******************************************/
/*****************************************************************************/
/*                                                                           */
/* FUNCTION NAME =     htx_profile()                                         */
/*                                                                           */
/* DESCRIPTIVE NAME =  Reads ".htx_profile" file                             */
/*                                                                           */
/* FUNCTION =          Reads HTX environment parameters from the file        */
/*                        /usr/lpp/htx/.htx_profile.                         */
/*                                                                           */
/* INPUT =             .htx_profile file - an attribute file which contains  */
/*                         the HTX environment parameter specifications.     */
/*                                                                           */
/* OUTPUT =            autostart - a string which contains the value of the  */
/*                         auto-startup flag.                                */
/*                                                                           */
/* NORMAL RETURN =     None - function type is void                          */
/*                                                                           */
/* ERROR RETURNS =     None - function type is void                          */
/*                                                                           */
/* EXTERNAL REFERENCES                                                       */
/*                                                                           */
/*    DATA AREAS =     HTXPATH - pointer to a string which contains the path */
/*                         to the top level of the HTX file hierarchy        */
/*                         (usually "/usr/lpp/htx").                         */
/*                     stress_dev - pointer to a string which contains the   */
/*                         name of the "heartbeat" device for stress lab     */
/*                         testing.  A null string means that no "heartbeat" */
/*                         is required -- non-stress test.                   */
/*                     stress_cycle - pointer to a string which contains the */
/*                         number of seconds between "heartbeats".           */
/*                         A null string means that no "heartbeat" is        */
/*                         required.                                         */
/*                                                                           */
/*****************************************************************************/

void htx_profile(int *autostart)
{
  /*
   ***  variable/function definitions  ****************************************
   */

  CFG__SFT *pro_fd;                    /* pointer to MDT attribute file     */

  char     stanza[4096];               /* stanza area for attribute file    */
  char     workstr[128];               /* work string                       */
DBTRACE(DBENTRY,("enter eservd.c htx_profile\n"));

  /*
   ***  beginning of executable code  ****************************************
   */

  (void) strcpy(workstr, HTXPATH);     /* copy HTX file system path         */
  pro_fd = cfgcopsf(strcat(workstr,"/.htx_profile"));
  if ((pro_fd != (CFG__SFT *) NULL) &&
      (cfgcrdsz(pro_fd, stanza, sizeof(stanza), (char *) NULL) == CFG_SUCC))
    {
      (void) cfgcskwd("run_mode", stanza, workstr);
      (void) unquote(workstr);             /* no quotes                     */
      switch (*workstr)
        {
        case 'r':
        case 'R':
          profile_emc_mode = 0;
          break;
        default:
          profile_emc_mode = 1;
          break;
        } /* endswitch */

      (void) cfgcskwd("max_err_file", stanza, MAX_ERR_THRES);
      (void) unquote(MAX_ERR_THRES);
      (void) cfgcskwd("max_err_save", stanza, MAX_ERR_SAVE);
      (void) unquote(MAX_ERR_SAVE);
      (void) cfgcskwd("err_wrap", stanza, ERR_WRAP);
      (void) unquote(ERR_WRAP);             /* no quotes */
      if ((*ERR_WRAP != 'y') && (*ERR_WRAP != 'Y'))
        {
          (void) strcpy(ERR_WRAP, "no");
        }
      else
        {
          (void) strcpy(ERR_WRAP, "yes");
        } /* endif */

      (void) cfgcskwd("max_msg_file", stanza, MAX_MSG_THRES);
      (void) unquote(MAX_MSG_THRES);
      (void) cfgcskwd("msg_archive", stanza, MSG_ARCHIVE);
      (void) unquote(MSG_ARCHIVE);
      if ((*MSG_ARCHIVE != 'y') && (*MSG_ARCHIVE != 'Y'))
        {
          (void) strcpy(MSG_ARCHIVE, "no");
        }
      else
        {
          (void) strcpy(MSG_ARCHIVE, "yes");
        } /* endif */

      (void) cfgcskwd("max_msg_save", stanza, MAX_MSG_SAVE);
      (void) unquote(MAX_MSG_SAVE);
      (void) cfgcskwd("msg_wrap", stanza, MSG_WRAP);
      (void) unquote(MSG_WRAP);             /* no quotes */
      if ((*MSG_WRAP != 'y') && (*MSG_WRAP != 'Y'))
        {
          (void) strcpy(MSG_WRAP, "no");
        }
      else
        {
          (void) strcpy(MSG_WRAP, "yes");
        } /* endif */

      (void) cfgcskwd("stx_autostart", stanza, workstr);
      (void) unquote(workstr);             /* no quotes */
      if ((workstr[0] != 'y') && (workstr[0] != 'Y'))
        {
          *autostart = 0;
        }
      else
        {
          *autostart = 1;
        } /* endif */

      (void) cfgcskwd("stress_dev", stanza, stress_dev);
      (void) unquote(stress_dev);             /* no quotes */
      if (strlen(stress_dev) == 0)            /* null string? */
        (void) strcpy(stress_dev, "/dev/null");

      (void) cfgcskwd("stress_cycle", stanza, stress_cycle);
      (void) unquote(stress_cycle);           /* no quotes */
      if (strlen(stress_cycle) == 0)          /* null string? */
        (void) strcpy(stress_cycle, "0");

      (void) cfgcskwd("hang_mon_period", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      HANG_MON_PERIOD = atoi(workstr);

      (void) cfgcskwd("slow_shutd_wait", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      slow_shutd_wait = atoi(workstr);

	  (void) strcpy(workstr,"0");
      (void) cfgcskwd("max_added_devices", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      MAX_ADDED_DEVICES = atoi(workstr);

      (void) cfgcskwd("max_exer_entries", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      MAX_EXER_ENTRIES = atoi(workstr);

      (void) cfgcskwd("max_ecgs", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      MAX_ECG_ENTRIES = atoi(workstr);

      (void) cfgcskwd("daemon_log_wrap", stanza, workstr);
      (void) unquote(workstr);               /* no quotes */
      DAEMON_LOG_WRAP = atoi(workstr);

      /* close .htx_profile cfg file */
      if (cfgcclsf(pro_fd) != CFG_SUCC)
        {
          print_log(LOGERR,"ERROR: Unable to close .htx_profile file.");
        } /* endif */

    }
  else
    {
      profile_emc_mode = 0;          /* REG run mode                   */

      (void) strcpy(MAX_ERR_THRES, "2000000");
      (void) strcpy(MAX_ERR_SAVE, "10000");
      (void) strcpy(ERR_WRAP, "yes");

      (void) strcpy(MAX_MSG_THRES, "4000000");
      (void) strcpy(MSG_ARCHIVE, "yes");
      (void) strcpy(MAX_MSG_SAVE, "10000");
      (void) strcpy(MSG_WRAP, "yes");
      (void) strcpy(stress_dev, "");
      (void) strcpy(stress_cycle, "");

	  MAX_ADDED_DEVICES = 0;
      *autostart = 0;
      shutd_wait = SD_DEFAULT;
      HANG_MON_PERIOD = 0;

    } /* endif */

DBTRACE(DBEXIT,("return eservd.c htx_profile\n"));
  return;
} /* htx_profile() */


/*****************************************************************************/
/*****  i n i t _ s c r e e n ( )  *******************************************/
/*****************************************************************************/
/*                                                                           */
/* FUNCTION NAME =     init_screen()                                         */
/*                                                                           */
/* DESCRIPTIVE NAME =  Initializes the display screen                        */
/*                                                                           */
/* FUNCTION =          Initializes the display screen for use with the       */
/*                     various CURSES routines.                              */
/*                                                                           */
/* INPUT =             None                                                  */
/*                                                                           */
/* OUTPUT =            Various CURSES initialization routine are called      */
/*                                                                           */
/* NORMAL RETURN =     None - function type is void                          */
/*                                                                           */
/* ERROR RETURNS =     None - function type is void                          */
/*                                                                           */
/* EXTERNAL REFERENCES                                                       */
/*                     None.                                                 */
/*                                                                           */
/*****************************************************************************/

/*****************************************************************************/
/*****  s i g _ e n d ( )  ***************************************************/
/*****************************************************************************/
/*                                                                           */
/* FUNCTION NAME =     sig_end()                                             */
/*                                                                           */
/* DESCRIPTIVE NAME =  Processes signals which end the program               */
/*                                                                           */
/* FUNCTION =          Sends the proper exit code to the end_it function to  */
/*                     show that the supervisor is ending due to a signal.   */
/*                                                                           */
/* INPUT =             sig - the value of the signal                         */
/*                                                                           */
/* OUTPUT =            The exit code which shows why the supervisor is       */
/*                     ending.                                               */
/*                                                                           */
/* NORMAL RETURN =     0x80 | sig - the exit code.                           */
/*                                                                           */
/* ERROR RETURNS =     None                                                  */
/*                                                                           */
/* EXTERNAL REFERENCES                                                       */
/*    OTHER ROUTINES = end_it - clean-up processing for ending program       */
/*                     send_message - sends messages to message handler prog */
/*                                                                           */
/*    MACROS =         PRTMSG - Print message CURSES macro                   */
/*                              (defined in common/hxiconv.h)                */
/*                                                                           */
/*****************************************************************************/
void   sig_end(int sig, int code, struct sigcontext *scp)
{
    char   workstr[81];                  /* work string                       */
    DBTRACE(DBENTRY,("enter eservd.c sig_end\n"));
  /*
   *** Beginning of Executable Code...  **************************************
   */
    print_log(LOGMSG," in sig_end. signal = %d\n",sig); fflush(stdout);
    if (sig == 13) // This error comes when sending a message and no one is there to receive it
      {
	  DBTRACE(DBEXIT,("return/a eservd.c sig_end\n"));
	  return;
      }
    if (sig_end_flag ==0) {
	(void) sprintf(workstr, "HTX supervisor canceled by signal %d.", sig);
	(void) send_message(workstr, sig, HTX_SYS_INFO, HTX_SYS_MSG);
	sig_end_flag = 1;
	end_it((0x00000080 | sig));
    } /* endif */
    DBTRACE(DBEXIT,("return/b eservd.c sig_end\n"));
    return;
} /* sig_end() */

/**************************************************************************/
/* Get # of exercisers still running                                      */
/**************************************************************************/
int
get_exer(int fd)
{
    char buf[1024];
    FILE  *fp;
    int exer;
    char running_msg[80];
    DBTRACE(DBENTRY,("enter eservd.c get_exer\n"));

    if ((fp = popen("ps -ef | grep hxe |grep dev | wc -l", "r")) == NULL) {
	print_log(LOGERR,"popen error in get_exer");
	sleep(5);
    } /* endif */
    if (fgets(buf,1024,fp) == NULL) {
	print_log(LOGERR,"fgets error in get_exer");
	sleep(5);
    } /* endif */
    sscanf(buf,"%d",&exer);
    pclose(fp);
    if (exer <0)
	exer=0;
    sprintf(running_msg,"Number of exercisers still running %d.\n", exer);
    if (fd <0)
	send_err_msg((0-fd), running_msg, -1);

    DBTRACE(DBEXIT,("return eservd.c get_exer\n"));
    return(exer);
} /* end get_exer */

/**************************************************************************/
/* Put out message if exercisers still running                            */
/**************************************************************************/
void exer_running_msg(int fd)
{
    char buf[1024];
    FILE  *fp;
    char running_msg[80];
    DBTRACE(DBENTRY,("enter eservd.c exer_running_msg\n"));

    if ((fp = popen("ps -ef | grep hxe | grep dev | grep -v \"grep hxe\" | awk '{print $9}'", "r")) ==NULL) {
	print_log(LOGERR,"popen error in exer_running_msg");
	sleep(5);
	DBTRACE(DBEXIT,("return/a eservd.c exer_running_msg\n"));
	return;
    } /* endif */
    if (fgets(buf,1024,fp) == NULL) {
	pclose(fp);	/* close pipe before returning */
	DBTRACE(DBEXIT,("return/b eservd.c exer_running_msg\n"));
	return;
    } /* endif */
    //CLRLIN(MSGLINE, 0);
    print_log(LOGMSG,"Still running - %s", buf);
    sprintf(running_msg,"Still Running  - %s\n", buf);
    if (fd <0)
	send_err_msg((0-fd), running_msg, -1);
    pclose(fp);
    DBTRACE(DBEXIT,("return/c eservd.c exer_running_msg\n"));
    return;
} /* end exer_running_msg */

void get_htx_level()
{
    int fileid,level_str_len;
    char *lev1, *lev2, tmpstr[80];
    FILE *fileptr;
    DBTRACE(DBENTRY,("enter eservd.c get_htx_level\n"));

    print_log(LOGMSG,"in get_htx_level\n");
    sprintf(level_str,"HTX ");

#if !defined(__HTX_LINUX__)  && !defined(__OS400__)  /* 400 */
    if ((fileid = open(getenv("HTXAIXLEVEL"), O_RDONLY)) != -1)
    {
	if ((level_str_len = read(fileid, level_str, 78)) <= 0)
	{
	    (void) strcpy(level_str, "AIX ???? -- HTX ????");
	}
	(void) close(fileid);
    }
    else
    {
	(void) strcpy(level_str, "AIX ???? -- HTX ????");
    }

#else

    if ((fileid = open("/usr/lpp/htx/htxlinuxlevel", O_RDONLY)) != -1) {
	if ((level_str_len = read(fileid, tmpstr, 78)) <= 0) {
	    htx_strcpy(tmpstr, "lhtx");
	}
	else {
	    tmpstr[78] = '\0';
	    lev1 = strchr(tmpstr,'(');
	    if (lev1 != NULL) {
		lev1++;
		print_log(LOGMSG,"lev1 = %s : len + %d\n",lev1,strlen(lev1));

		lev2 = strchr(lev1,'-');
		if (lev2 != NULL)
		{
		  lev2--;
		  print_log(LOGMSG,"lev2 = %s : len + %d\n",lev2,strlen(lev2));
		//strncat(level_str,lev1,(strlen(lev1) - strlen(lev2)));
		  level_str_len = strlen(lev1) - strlen(lev2);
		  strncpy(level_str,lev1,level_str_len);
		}
		level_str[level_str_len] = '/';
	    }
	    else
		htx_strcpy(level_str,"unknown/");
	    level_str_len = strlen(level_str);
	    print_log(LOGMSG,"level_str = %s len = %d \n",level_str,strlen(level_str));
	}

	close(fileid);
    }

    if ((fileptr = popen("uname -r", "r")) != NULL) {
	print_log(LOGMSG,"popen successful\n");
	lev1 = (char *)malloc(80);
	if (fgets(lev1,20,fileptr) == NULL) {
	    print_log(LOGERR,"Erorr getting level from fgets. errno = %d (%s)\n",errno,strerror(errno));
	    fflush(stdout);
	    htx_strcat(level_str,"LINUX");
	    level_str_len = level_str_len + 5;
	}      /* endif */
	else {
	    strncat(level_str,lev1,(strlen(lev1)-1));
	    level_str[level_str_len+strlen(lev1)] = '\0';
	    print_log(LOGMSG,"lev1 = %s strlen(lev1) = %d\n",lev1,strlen(lev1));
	    fflush(stdout);
	}
	pclose(fileptr);
    }

    else {
	print_log(LOGERR,"popen error. errno = %d (%s)\n",errno,strerror(errno));
	DBTRACE(DBEXIT,("return eservd.c get_htx_level\n"));
	return;
    }
#endif

    if (strlen(level_str) >= 21)
	level_str[21] = '\0';

    print_log(LOGMSG,"level = %s\n",level_str);
    fflush(stdout);
    DBTRACE(DBEXIT,("leave eservd.c get_htx_level\n"));
}


void end_ecg()
{
    int  i;             /* loop counter                      */
    int  rc_ipc;           /* Return code from ipc calles       */
    int  ent, local_pid;
    char sysstr[256];
    int kr;
    int num_exer_running;
	char buf[512];
    FILE *fp;

    union semun
    {
	int val;
	struct semid_ds *buf;
	unsigned short *array;
    } semctl_arg;

    union shm_pointers shm_wrk_ptr;      /* pointer into shared memory        */
    DBTRACE(DBENTRY,("enter eservd.c end_ecg\n"));

     /* printf("cur_ecg_pos = %d, ECGSTATUS = %s\n",cur_ecg_pos,ECGSTATUS); */

    ent = ECGSHMADDR_HDR->max_entries;
    print_log(LOGMSG,"in end_ecg for %s total = %d entries = %d\n",ECGNAME,NUM_EXERS,ECG_MAX_ENTRIES); fflush(stdout);

    /* release all semphore locks */
    semctl_arg.array = (ushort*) malloc(sem_length * sizeof(ushort) );
    if(semctl_arg.array == NULL) {
	sprintf(buf, "Unable to allocate memory for semctl SETVAL array.  errno = %d.", errno);
	send_message(buf, errno, HTX_SYS_HARD_ERROR, HTX_SYS_MSG);
	return;
    }
    memset(semctl_arg.array, 0, (sem_length * sizeof(ushort) ) );
    semctl(semhe_id, 0, SETALL, semctl_arg);
    free(semctl_arg.array);
    semctl_arg.array = NULL;

    if (ECGSHMADDR_HDR != 0) {
	print_log(LOGMSG,"Shutdown in progress.\n"); fflush(stdout);
	(ECGSHMADDR_HDR)->shutdown = 1; /* Shutdown in progress         */
	print_log(LOGMSG,"setting the shutdown flag:%d(0x%x)\n",
        (ECGSHMADDR_HDR)->shutdown, ECGSHMADDR_HDR);
	shm_wrk_ptr.hdr_addr = ECGSHMADDR_HDR + 1;  /* skip over header     */
	SEMCTL(ECGSEMHEID, 0, SETVAL, 0);   /* defect 365157 */

	for (i = 0; i < (shm_addr.hdr_addr)->max_entries; i++) {
	    local_pid = (shm_wrk_ptr.HE_addr + i)->PID;
	    if ( ((shm_wrk_ptr.HE_addr + i)->PID) != 0) { /* Process ID defined?  */
		(shm_wrk_ptr.HE_addr + i)->max_cycles = 0; /* defect 362468 */
		SEMCTL(ECGSEMHEID, (i* SEM_PER_EXER + SEM_GLOBAL), SETVAL, 0);   /* defect 362881 */
		SEMCTL(ECGSEMHEID, (i* SEM_PER_EXER + SEM_GLOBAL + 1), SETVAL, 0);
		if((equaliser_flag == 1) && ((shm_wrk_ptr.HE_addr + i)->equaliser_halt == 1)) {
			(void) kill(local_pid, SIGCONT);
			sleep(2);
		}
		(void) kill(local_pid, SIGTERM);
	    } /* endif */
	} /* endfor */
    } /* endif */

    for (i = 0; i < (shm_addr.hdr_addr)->max_entries; i++) {
	if (((shm_wrk_ptr.HE_addr + i)->PID != 0) &&
	    ((shm_wrk_ptr.HE_addr + i)->is_child)) {
	    print_log(LOGMSG,"Still Running ... %s ...\n",(shm_wrk_ptr.HE_addr + i)->sdev_id);
	}
	else if ((shm_wrk_ptr.HE_addr + i)->is_child == 0) {
	    print_log(LOGMSG,"Device %s is not child. num = %d max = %d i = %d\n",(shm_wrk_ptr.HE_addr + i)->sdev_id,ECGSHMADDR_HDR->num_entries, (shm_addr.hdr_addr)->max_entries, i);
	    fflush(stdout);
	    (ECGSHMADDR_HDR->num_entries)--;
	}
    }
    i=0;
    print_log(LOGMSG,"ECG %s is in %s state. entries = %d\n", ECGNAME, ECGSTATUS, ECG_MAX_ENTRIES); fflush(stdout);
    if (strcmp(ECGSTATUS,"ACTIVE") == 0) {
	        if ((fp = popen("ps -ef | grep hxe | grep -v \"grep hxe\" | wc -l", "r")) == NULL ) {
	                print_log(LOGERR, "popen failed...exiting\n");
	                return ;
	          }
	        fgets(buf,512,fp);
	        num_exer_running = atoi(buf);
	        print_log(LOGMSG,"num_exer_running = %d\n",num_exer_running);

	    if(num_exer_running){
		/* printf("Waiting for exercisers to terminate...\n"); */
	    	 while (ECGSHMADDR_HDR->num_entries>0) {
			    i++;
			    print_log(LOGMSG,"Still Running %d exercisers\n", ECGSHMADDR_HDR->num_entries); fflush(stdout);
			    if ((ECGSHMADDR_HDR->num_entries <=0) || (i>200))
					break;
				    sleep(4);
		  	 }
		}
    	pclose(fp);
     }

     if ((equaliser_PID != 0) && (strcmp(ECGNAME, "mdt.eq") == 0)) {
		 (void)kill(equaliser_PID, SIGTERM);
		 equaliser_PID = 0;
		 equaliser_flag = 0;
	 }
	 for (i = 0; i < (shm_addr.hdr_addr)->max_entries; i++)
        if ((shm_wrk_ptr.HE_addr + i)->PID != 0) {
		kr = kill((shm_wrk_ptr.HE_addr + i)->PID,SIGKILL);
		if(kr == 0)
	     		ECGSHMADDR_HDR->num_entries--;

		(shm_wrk_ptr.HE_addr + i)->PID = 0;
	}

     ECGSHMADDR_HDR->num_entries = 0;
     system_call = TRUE;
     system("ps -ef | grep sct2_ | grep -v grep | awk '{print $2}' | xargs kill -9 >/dev/null 2>&1");
     system_call = FALSE;

    /* printf("num_entries = %d\n",ECGSHMADDR_HDR->num_entries); */
    print_log(LOGMSG,"Entries should be 0 now. ECG %s  %s state. entries = %d\n", ECGNAME, ECGSTATUS, ECG_MAX_ENTRIES); fflush(stdout);
    for (i = 0; i < ECG_MAX_ENTRIES; i++) {
	//print_log(LOGMSG,"Calling rmv . i =%d id = :%s:\n",i, (shm_wrk_ptr.HE_addr + i)->sdev_id); fflush(stdout);
	/* printf("Calling rmv . i =%d id = :%s:\n",i, (shm_wrk_ptr.HE_addr + i)->sdev_id); fflush(stdout); */
	rmv_ecg_all((shm_wrk_ptr.HE_addr + i)->sdev_id);
	ECGEXER_SEMID(i) = 0;
	ECGEXER_SHMKEY(i) = 0;
	ECGEXER_SEMKEY(i) = 0;
	ECGEXER_POS(i)    = 0;
	ECGEXER_HDR(i)    = 0;
	EXER_PID(i)       = 0;
	EXER_NAME(i)[0]   = '\0';
    }
  /*  get rid of semaphore structures  */
    print_log(LOGMSG,"semhe_id = %d\n", ECGSEMHEID); fflush(stdout);
    if (ECGSEMHEID != -1) {
	rc_ipc = semctl(ECGSEMHEID, (int) NULL, IPC_RMID, (struct semid_ds *) NULL);
	if (rc_ipc == -1) {
	    print_log(LOGERR,"Error in semctl call for ECGSEMHEID= %d(0x%x) in end_it. Errno = %d (%s)\n", ECGSEMHEID, ECGSEMHEID, errno, strerror(errno));
	    fflush(stdout);
	}
	else {
	    print_log(LOGMSG,"Done removing ECGSEMHEID = %d %x...",ECGSEMHEID, ECGSEMHEID);
	    fflush(stdout);
	}
    }

  /*  get rid of shared memory structure  */
    if ( (EXER_LIST != NULL) && (cur_ecg_pos != 0) ) {
	free(EXER_LIST);
	EXER_LIST = 0;
    }
    if (ECGSHMID != -1) {
	shm_addr.hdr_addr->started = 0;
	rc_ipc = shmdt(shm_addr.hdr_addr);
	if (rc_ipc == -1)
	    print_log(LOGERR,"Error in shmdt call for shm_addr->hdr_addr= %d(0x%x) in end_it. Errno = %d (%s)\n", (int)shm_addr.hdr_addr, (int)shm_addr.hdr_addr, errno, strerror(errno));
	else
	    print_log(LOGMSG,"Done detaching shm_addr.hdr_addr = %d %x...",(int)shm_addr.hdr_addr, (int)shm_addr.hdr_addr);
	rc_ipc = shmctl(ECGSHMID, IPC_RMID, (struct shmid_ds *) NULL);
	if (rc_ipc == -1)
	    print_log(LOGERR,"Error in shmctl call for ECGSHMID= %d(0x%x) in end_it. Errno = %d (%s)\n", ECGSHMID, ECGSHMID, errno, strerror(errno));
	else
	    print_log(LOGMSG,"Done removing ECGSHMID = %d %x...\n",ECGSHMID, ECGSHMID);
	shm_addr.hdr_addr = 0;
    rem_shm_addr->sock_hdr_addr->cur_shm_key = 0;
    }
    ECGSHMADDR_HDR = 0;
    ECGSHMADDR_HE = 0;
    ECG_MAX_ENTRIES = 0;
    ECGSHMID = 0;
    ECGSEMHEID = 0;

     /* printf("Before strcmp,cur_ecg_pos = %d, ECGSTATUS = %s\n",cur_ecg_pos,ECGSTATUS); */

    /***************************************************************************/
    /**  Run HTX post processing script ****************************************/
    /***************************************************************************/
    if (strcmp(ECGSTATUS,"INACTIVE")) {
      print_log(LOGMSG,"running exer_cleanup for %s/%s\n",ECGPATH,ECGNAME); fflush(stdout);
      sprintf(sysstr,"/usr/lpp/htx/etc/scripts/exer_cleanup %s/%s 2>/tmp/res_cleanup", ECGPATH,ECGNAME);
      system_call = TRUE;
      system(sysstr);
      system_call = FALSE;
    }

    /* printf("\n End of end_ecg\n"); */
    DBTRACE(DBEXIT,("return eservd.c end_ecg\n"));
    return;                              /*  this statement only for lint     */
}
