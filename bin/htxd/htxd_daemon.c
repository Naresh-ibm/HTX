/* IBM_PROLOG_BEGIN_TAG */
/* 
 * Copyright 2003,2016 IBM International Business Machines Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 		 http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* IBM_PROLOG_END_TAG */
/* @(#)38	1.8  src/htx/usr/lpp/htx/bin/htxd/htxd_daemon.c, htxd, htxfedora 9/15/15 20:28:01 */



#include <stdio.h>


#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <errno.h>

#ifndef __HTX_LINUX__    /** AIX **/
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netdb.h>
 #include <arpa/inet.h>
#endif

#include "htxd_socket.h"
#include "htxd_signal.h"
#include "htxd_option_methods.h"
#include "htxd.h"
#include "htxd_instance.h"
#include "htxd_define.h"
#include "htxd_thread.h"
#include "htxd_trace.h"
#include "htxd_util.h"

extern volatile int htxd_shutdown_flag;

extern int htxd_shutdown_all_mdt(void);
extern int htxd_stop_hotplug_monitor(htxd_thread **);
extern int htxd_autostart(htxd *);
extern int detach_syscfg();

/* daemon live here, receives command, process it, send back result */
int htxd_start_daemon(htxd *htxd_instance)
{

	int					result				= 0;
	int					socket_fd;
	struct sockaddr_in	local_address;
	struct sockaddr_in	client_address;
	socklen_t			address_length;
	int					new_fd;
	char *				command_buffer		= NULL;
	char *				command_result		= NULL;
	int					command_return_code	= 0;
	char			trace_string[256];


	HTXD_FUNCTION_TRACE(FUN_ENTRY, "htxd_start_daemon");

	init_option_list();
	htxd_autostart(htxd_instance);  /* try autostart if find the autostart flag file */

	socket_fd = htxd_create_socket();

	result = htxd_set_socket_option(socket_fd);

	local_address.sin_family = AF_INET;
	local_address.sin_port = htons (htxd_instance->port_number);
	local_address.sin_addr.s_addr = INADDR_ANY;
	memset (&(local_address.sin_zero), '\0', 8);

	result = htxd_bind_socket(socket_fd, &local_address, htxd_instance->port_number);

	result = htxd_listen_socket(socket_fd);

	HTXD_TRACE(LOG_ON, "starting daemon main loop");
	do  /* this loop make the daemon live */
	{
		do  /* this loop listens for incoming messages */
		{
			HTXD_TRACE(LOG_OFF, "daemon wating for command");
			result = htxd_select(socket_fd);
			if(htxd_shutdown_flag == TRUE) {
				break;
			}
		}while( (result == -1) && (errno == EINTR) );
		if(htxd_shutdown_flag == TRUE) {
			break;
		}

		new_fd = htxd_accept_connection(socket_fd, &client_address, &address_length);
		if(new_fd == -1)
		{
			if(htxd_shutdown_flag == TRUE) {
				break;
			}
			HTXD_TRACE(LOG_OFF, "select time out");
			continue;
		}

		HTXD_TRACE(LOG_OFF, "found a command for receiving");
	
		if(htxd_is_profile_initialized(htxd_instance) != TRUE) {
			HTXD_TRACE(LOG_ON, "initialize HTX profile details");
			htxd_init_profile(&(htxd_instance->p_profile));
			/* htxd_display_profile(htxd_instance->p_profile);  */ /* To DEBUG */
			register_signal_handlers();	
		}

		/* receive the incoming command */
		HTXD_TRACE(LOG_OFF, "daemon receiving command");
		command_buffer = htxd_receive_command(new_fd);
		if(command_buffer == NULL)
		{
			return -1;
		}

		HTXD_TRACE(LOG_OFF, "command received start<<");
		HTXD_TRACE(LOG_OFF, command_buffer);
		HTXD_TRACE(LOG_OFF, ">> command received end");

		htxd_update_command_object(command_buffer);

		if(command_buffer != NULL) {
			free(command_buffer);
			command_buffer = NULL;
		} 

		/* process the received command */
		HTXD_TRACE(LOG_OFF, "daemon start processing command");
		command_return_code = htxd_process_command(&command_result);

		/* handling if command did not generate result buffer */		
		if(command_result == NULL) {
			command_result = malloc(HTX_ERR_MESSAGE_LENGTH);
			if(command_result == NULL) {
				sprintf(trace_string, "Error : malloc(%d) failed with errno = <%d> while allocating error message", HTX_ERR_MESSAGE_LENGTH, errno);
				HTXD_TRACE(LOG_ON, trace_string); 
				exit(1);
			}
			strcpy(command_result, "No result is generated by the command");
		}

		HTXD_TRACE(LOG_OFF, "command result start<<");
		HTXD_TRACE(LOG_OFF, command_result);
		HTXD_TRACE(LOG_OFF, ">> command result end");

		/* send back command result to client */
		HTXD_TRACE(LOG_OFF, "daemon sending the result to client");
		result = htxd_send_response(new_fd, command_result, command_return_code);
		if(result == -1)
		{
			return result;
		}
		
		if(command_result != 0) {
			free(command_result);
		}
		close(new_fd);

	} while(htxd_shutdown_flag == FALSE);

	if(htxd_get_ecg_list_length(htxd_instance->p_ecg_manager) > 0)
	{
		/* shutdown all running ecgs and return */	
		// htxd_shutdown_all_running_ecgs();
	}

	htxd_shutdown_all_mdt();

	HTXD_FUNCTION_TRACE(FUN_EXIT, "htxd_start_daemon");

	return result;
}



void htxd_cleanup_system_shm(void)
{
	int shm_id;
	void *shm_address;

	shm_id = htxd_get_exer_table_shm_id();
	shm_address = (void *) htxd_get_exer_table();
	htxd_cleanup_shm(shm_id, shm_address);

	shm_id = htxd_get_system_header_info_shm_id();
	shm_address = (void *) htxd_get_system_header_info();
	htxd_cleanup_shm(shm_id, shm_address);

	htxd_delete_ecg_manager();

	htxd_set_daemon_state(HTXD_DAEMON_UNVALIDATED);
}



/* putting daemon back to idle state */
int htxd_idle_daemon(void)
{
	int return_code;
	char trace_string[256];
	pid_t htx_stats_pid;
	htxd *htxd_instance;
#ifdef __HTXD_DR__
	pid_t htx_dr_child_pid;
#endif

	
	if(htxd_is_hang_monitor_initialized() == TRUE) {
		htxd_instance = htxd_get_instance();
		htxd_stop_hang_monitor(&(htxd_instance->p_hang_monitor_thread));
		htxd_remove_hang_monitor();
	}

	
	htx_stats_pid = htxd_get_htx_stats_pid();
	if (htx_stats_pid != 0) {
		htxd_send_SIGTERM(htx_stats_pid);
	}

#ifdef __HTX_LINUX__
	if(htxd_is_hotplug_monitor_initialized() == TRUE) {
		htxd_instance = htxd_get_instance();
		htxd_stop_hotplug_monitor(&(htxd_instance->p_hotplug_monitor_thread));
		htxd_remove_hotplug_monitor();
	}
#endif


#ifdef __HTXD_DR__
	htx_dr_child_pid = htxd_get_dr_child_pid();
	if (htx_dr_child_pid != 0) {
		htxd_send_SIGTERM(htx_dr_child_pid);
	}
#endif
	
	htxd_send_message ("System into idle state", 0, HTX_SYS_INFO, HTX_SYS_FINAL_MSG);

	while(1) {
#ifdef __HTXD_DR__
		if( (htx_stats_pid == 0) &&  (htx_dr_child_pid == 0) ) {
			break;
		}
		htx_stats_pid = htxd_get_htx_stats_pid();
		htx_dr_child_pid = htxd_get_dr_child_pid();
		sleep(1);
#else
		if(htx_stats_pid == 0) {
			break;
		}

		htx_stats_pid = htxd_get_htx_stats_pid();
		sleep(1);
#endif

	}

	if (htxd_is_init_syscfg() == TRUE) {
		return_code = detach_syscfg();
		if(return_code != 0) {
			sprintf(trace_string, "Internal error: failed to detach syscfg with error code <%d>", return_code);
			HTXD_TRACE(LOG_ON, trace_string);
		}
		htxd_set_init_syscfg_flag(FALSE);
	}

	htxd_cleanup_system_shm();

	return 0;
}
