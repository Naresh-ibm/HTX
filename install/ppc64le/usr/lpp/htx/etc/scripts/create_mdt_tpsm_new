#!/usr/bin/perl -w
use strict;
use Getopt::Long qw(GetOptionsFromString);
use File::Basename;
use Data::Dumper;

my $BASE = "";
my $mmap_file_path = "$BASE/home/utpsm/";
my $rdir = "";
my $mdir = "";
my $mdtfile = "";
my $ncpu = 0;
my $cpu_set_size=8;
my $infile = "";
my $usecapi = 1;
my $aix = 0;

#Before executing anything else determine we are on AIX or Linux
my $os = `uname`;
chomp($os);
if($os =~ m/AIX/i)
{
	$aix = 1;
}

my $proclist= $aix ? `bindprocessor -q | cut -d' ' -f6-` : `egrep cpu?[0-9] /proc/stat | cut -f1 -d' ' | cut -f2 -d'u'`;
my @available_processors = ();
my $smt = find_smt_mode();
my $rule_file_idx=-1;

if( @ARGV == 0 && -e "default_inputs.txt" ){
	open DEFAULT_INPUTS_FILE, "default_inputs.txt" or die $!;
	my @inputs = <DEFAULT_INPUTS_FILE>;
	for my $input (@inputs){
		chomp $input;
		if($input){
			parseOptions(\$ncpu, \$infile, \$mdtfile, \$rdir, \$mdir, \$usecapi, $input);
			gen_mdt_htxtpsm();	
		}
	}
	close(DEFAULT_INPUTS_FILE);
	exit 0;
}else{
	parseOptions(\$ncpu, \$infile, \$mdtfile, \$rdir, \$mdir, \$usecapi);
	gen_mdt_htxtpsm();	
}


sub usage
{
	print "Name:".$0."\n";
	print "Description: Generate rules file for multiple cpus\n";
	print "Options:\n";
	print "    -help or --help: Display this message\n";
	print "    -ncpu or --ncpu <Number of cpus for which rules file is to be generated>\n";
	print "    -infile or --infile <Absolute path of input rules file>\n";
	print "    -mdtfile or --mdtfile <Name of the mdt file>\n";
	print "    -rdir or --rdir <Absolute path of directory where rule files are to be created>\n";
	print "    -mdir or --mdir <Absolute path of directory where mdt file is to be created>\n";
	print "    -capi or --capi <0|1> Flag indicating whether to use capi devices if they are available\n";
	print "    NOTE1: By default ncpu is equal to the number of threads available in the system\n";
	print "    NOTE2: By default mdtfile is set to mdt.tpsm\n";
	print "    NOTE3: By default rdir is set to /usr/lpp/htx/rules/reg/tpsm/\n";
	print "    NOTE4: By default mdir is set to /usr/lpp/htx/mdt/\n";
	print "    NOTE5: By default capi is set to 1 (i.e., capi devices will be used if available)\n";
}

sub parseOptions
{
	#All arguments are passed by reference
	my($ncpu, $infile, $mdtfile, $rdir, $mdir, $usecapi, $optionString) = @_;
	my $help = 0;
	if($optionString){
		GetOptionsFromString($optionString, 'help|?' => \$help, 'ncpu=i' => $ncpu, 'infile=s' => $infile, 
			'mdtfile=s' => $mdtfile,
			'rdir=s' => $rdir, 'mdir=s' => $mdir, 'capi=i' => $usecapi);
	}else{
		GetOptions('help|?' => \$help, 'ncpu=i' => $ncpu, 'infile=s' => $infile, 
			'mdtfile=s' => $mdtfile,
			'rdir=s' => $rdir, 'mdir=s' => $mdir, 'capi=i' => $usecapi);
	}
	
	if( $help )
	{
		usage();
		exit 0;
	}

	if($$ncpu == 0)
	{
		if( $aix )
		{
			$$ncpu = get_num_processors_aix();
		}
		else
		{
			$$ncpu = `egrep cpu?[0-9] /proc/stat |wc -l`;
		}
		chomp($$ncpu);
	}
	if($$mdtfile eq "")
	{
		$$mdtfile = "mdt.tpsm";
	}
	if($$infile eq "")
	{
		$$infile = "rules.template";
	}
	if($$rdir eq "")
	{
		$$rdir = "$BASE/usr/lpp/htx/rules/reg/tpsm/";
	}
	if($$mdir eq "")
	{
		$$mdir = "$BASE/usr/lpp/htx/mdt/";
	}
}

sub get_num_processors_aix
{
	my $STR = `bindprocessor -q`;
	my @lproc_temp = split(/:/, $STR);
	my @lproc = split(/\s+/, $lproc_temp[1]);
	my $num_lproc = 0;
	foreach my $num (@lproc)
	{
        	chomp($num);
        	if($num =~ m/^$/)
        	{
                	next;
        	}
        	else
        	{
                	$num_lproc++;
        	}
	}
	return $num_lproc;
}

sub gen_mdt_htxtpsm
{
	@available_processors = $aix ? split(/\W/, $proclist) : split(/\n/, $proclist);
	if(@available_processors > $ncpu){
		@available_processors = @available_processors[0..$ncpu-1];
	}
	my @config_files = glob("$rdir/default_templates/*config*txt");
	foreach my $config_file (@config_files){
		chomp $config_file;
	
		my @buildarray = build_rules($config_file);
		my @rules=@{$buildarray[0]};
		my %headers=%{$buildarray[1]};
		my $nrules=scalar @rules;
		if((not defined $headers{'stride'}) or $headers{'stride'}  eq 'SMT'){
			$headers{'stride'}=$smt;
		}
		if(! $headers{'stride'}){
			$headers{'stride'}=1;
		}
		if(! $headers{'gen_diff_ids_all_rules'}){
			$headers{'gen_diff_ids_all_rules'}=0;
		}
		if(!$headers{'split_rules'}){
			$headers{'split_rules'}=0;
		}
		my @cpu_lists = build_cpu_lists($headers{'stride'}, $nrules, $headers{'gen_diff_ids_all_rules'}, $headers{'num_splcpuids'});
		
		my $max_rules_per_stanza = $headers{'split_rules'}==1 ? 1 : $nrules;
	
		my @generated_rulefiles=();
		my @this_stanza_rules=();
		my $cpu_list_idx=-1;
		my @capi_devices = find_capi_devices();
	   my $max_dev_per_rule = 0;
		my @btf_dev_arr = ();
		my $btf_conf_path = "$rdir/default_templates";
		if(open(BTFCONF, "$btf_conf_path/tpsm_btf_conf_parms"))
		{
			 while(<BTFCONF>)
			 {
				  chomp($_);
				  if($_ =~ /MAX_CAPIDEV_PER_RULE/ )
				  {
						@btf_dev_arr = split(/=/, $_);
						chomp($btf_dev_arr[1]);
						$max_dev_per_rule = $btf_dev_arr[1];
				  }
			 }
			 close(BTFCONF);
			 print "DEBUG: max_dev_per_rule=$max_dev_per_rule\n";
		}
		else
		{
			 print "Either this is not a BTF environment or $btf_conf_path/tpsm_btf_conf_parms file was not created\n";
		}
		if($max_dev_per_rule == 0)
		{
			 $max_dev_per_rule = 8;
		}
		for my $cpu_list (@cpu_lists){
			$cpu_list_idx++;
			my $rule=$rules[$cpu_list_idx % $nrules];
			
			my @tmp_cpu_list = ();
			my @spl_cpu_list = ();
			foreach my $cpuid (@{$cpu_list}){
				if($cpuid =~ m/^s/){
					my $tmpcpuid=$cpuid;
					$tmpcpuid =~ s/s//;
					push @spl_cpu_list, $tmpcpuid;
				}else{
					push @tmp_cpu_list, $cpuid;
				}
			}
			@{$cpu_list} = @tmp_cpu_list;
			if(scalar @spl_cpu_list > 0){
				$rule =~ s/^cpuid=.*$/cpuid=@{$cpu_list}\nsplcpuid=@spl_cpu_list/mg;
			}else{
				$rule =~ s/^cpuid=.*$/cpuid=@{$cpu_list}/mg;
			}
			$rule =~ s/^mcpu=.*$/mcpu=${$cpu_list}[0]/mg;
			if(scalar @this_stanza_rules == $max_rules_per_stanza){
				my @cards_for_this_rulefile = ();
				while(@cards_for_this_rulefile<$max_dev_per_rule && @capi_devices>0){
	                my $next_available_card = shift(@capi_devices);
	            	if($next_available_card){
	                    push(@cards_for_this_rulefile, $next_available_card);
	            	}
				}
				push(@generated_rulefiles, print_rulefile(process_template(join("\n", @this_stanza_rules), {capi_devices  => \@cards_for_this_rulefile}, 1)));
				@this_stanza_rules=();
			}
			push @this_stanza_rules, $rule;
		}
		if(scalar @this_stanza_rules != 0){
			my @cards_for_this_rulefile = ();
			while(@cards_for_this_rulefile<$max_dev_per_rule && @capi_devices>0){
	        	my $next_available_card = shift(@capi_devices);
	            if($next_available_card){
	            	push(@cards_for_this_rulefile, $next_available_card);
	            }
			}
			push(@generated_rulefiles, print_rulefile(process_template(join("\n", @this_stanza_rules), {capi_devices  => \@cards_for_this_rulefile}, 1)));
		}
		
		my %ctxt = (rulefiles => \@generated_rulefiles);
		
		my $output = process_template("$rdir/default_templates/mdt.tpsm.template", \%ctxt);
		my $char_mdt=`basename $config_file .txt`;
		$char_mdt="mdt.tpsm_$char_mdt";
		$char_mdt =~ s/\s*$//;
		if($config_file =~ /default_config/){
			$char_mdt = $mdtfile;
		}
		open(MDTFILE, ">$mdir/$char_mdt") || die("Unable to open output file \"$mdir/$char_mdt\" for writing. Exiting.");
		print MDTFILE $output;
		close(MDTFILE);
		print "\nCreated $char_mdt ($mdir$char_mdt)\n";
	}
}

sub print_rulefile {
	my ($rule_text) = @_;
	$rule_file_idx++;
	my $outfile="tpsm";
	open(RULEFILE, ">$rdir/$outfile\_$rule_file_idx") || die("Unable to open rule file \"$rdir/$outfile\_$rule_file_idx\" for writing. Exiting. $!");
	print RULEFILE $rule_text;
	close(RULEFILE);
	return "$outfile\_$rule_file_idx";
}

sub build_cpu_lists {
	my ($stride, $nrules, $gen_diff_ids_all_rules, $num_splcpuids) = @_;
	
	$num_splcpuids = 0 if not defined $num_splcpuids;
	my $ncpus=scalar @available_processors;
	my @rows=();
	my @row=();
	for(my $j=0; $j<$stride; $j++){
		for(my $i=$j; $i<$ncpus; $i+=$stride){
			push @row, $available_processors[$i];
			if(scalar @row == 8){
				mark_special_cpus($num_splcpuids, \@row);
				for(my $k=0; $k<($gen_diff_ids_all_rules ? 1 : $nrules); $k++){
					my @tmpRow = @row;
					push @rows, \@tmpRow;
				}
				@row = ();
			}
		}
		if(scalar @row != 0){
				mark_special_cpus($num_splcpuids, \@row);
				for(my $k=0; $k<($gen_diff_ids_all_rules ? 1 : $nrules); $k++){
					my @tmpRow = @row;
					push @rows, \@tmpRow;
				};
				@row = ();
		}
	}
	@rows = sort {my $c=${$a}[0]; my $d=${$b}[0]; $c=~s/s//; $d=~s/s//; $c <=> $d} @rows;
	return @rows;
}

sub mark_special_cpus {
	my ($num_splcpuids, $cpu_list) = @_;
	if($num_splcpuids > scalar @{$cpu_list} - 1){
		$num_splcpuids = scalar @{$cpu_list} - 2; 
	}
	if($num_splcpuids < 0){
		$num_splcpuids = 0;
	}
	#print "num_splcpuids = $num_splcpuids\n";
	my @splcpuids=();
	if($num_splcpuids>0){
		for(my $splidx=int(rand(scalar @{$cpu_list} - $num_splcpuids)); (scalar @splcpuids) < $num_splcpuids; ){
			${$cpu_list}[$splidx + scalar @splcpuids] = "s" . ${$cpu_list}[$splidx + scalar @splcpuids];
			push @splcpuids, ${$cpu_list}[$splidx + scalar @splcpuids];
		}
	}
	#print join(',', @splcpuids), " out of ", join(',', @{$cpu_list}), "\n";
}

sub build_rules {
	my ($config_file) = @_;
	
	my @rules=();
	open MYFILE, "<", "$config_file" or die $!;
	my @rule_overrides=();
	my %current_rule=();
	my $header_section=1;
	my %headers;
	while(<MYFILE>){
		chomp $_;
		next if /^#/;
		$header_section = ($_ !~ /RULE_ID/) if $header_section;
		
		my ($parm_name, $parm_value) = m/^\s*(\w+)=(.*)/;
		next if ((not defined $parm_name) or $parm_name eq '');		
		
		if($header_section){
			$headers{$parm_name} = $parm_value;
			next;
		}
		
		$header_section = 0;
		
		if($parm_name eq 'RULE_ID'){
			if((scalar keys %current_rule)>0){
				my %tmp_current_rule = %current_rule;
				push @rule_overrides, \%tmp_current_rule;
				%current_rule=();
			}
		}
		$current_rule{$parm_name} = $parm_value;
	};
	if((scalar keys %current_rule)>0){
		push @rule_overrides, \%current_rule;
	}
	close MYFILE;
	
	my $rule_file = $headers{'rules'};
	if(!$rule_file){
		if($config_file =~ /default_config/){
			$rule_file = $infile;
		}else{
			print "Note: No rule file specified in $config_file\n;";
			return (\@rules, \%headers);
		}
	}
	$rule_file = "$rdir/default_templates/$rule_file";
	my %ctxt = (cpu_ids => [0], capi_devices  => [], mmap_file_path => $mmap_file_path, rule_template_dir => dirname($rule_file));
	my $rule = process_template($rule_file, \%ctxt);
	my @tmprules=split m/(?=^RULE_ID=.*$)/m, $rule;
	s/^\s*\n//mg foreach @tmprules;
	shift @tmprules if $tmprules[0] eq '';
	for my $override (@rule_overrides){
		$rule = undef;
		for(@tmprules){
			$rule = $_ if /^RULE_ID=${$override}{'RULE_ID'}/m;
		}
		if(defined $rule){
			my $tmprule=$rule;
			for (keys %{$override}) {
				unless($tmprule =~ s/^$_=.*$/$_=${$override}{$_}/mg){
					chomp $tmprule;
                	$tmprule = "$tmprule\n$_=${$override}{$_}";
                }
			}
			push @rules, $tmprule;
		}
	}
	
	return (\@rules, \%headers);
}

sub process_template
{
	my ($templateFile, $context, $post) = @_;
	my %ctxt = %$context;
	
	my $inp = undef;
	if(! $post){
		if(-e $templateFile){
			open TEMPLATE_FILE, $templateFile or die $!;
			my @inputs = <TEMPLATE_FILE>;
			$inp = join('', @inputs);
			close TEMPLATE_FILE;
		}else{
			print "Cannot find $templateFile\n"; 
			return;
		}
	}
	if((not defined $inp) and $post){
		$inp = $templateFile;
	}

	if(! $post){
		$inp =~ s/<%([^=].*?)%>/eval $1/ges;
	}else{
		$inp =~ s/<%=(.*?)%>/eval $1/ges;
	}
	my $nl = $/;
	$/ = "";
	chomp $inp;
	$/ = $nl;
	
	return $inp . "\n";
	
}
sub find_smt_mode{
	my $smt=0;
	if ($aix){
		$_=`bindprocessor -b 0 2>&1`;
		m/[^:]*:\s*(.*)/; $_=$1; # get the digits
		s/^\s*//; s/\s*$//; s/\s+/,/g; # and make it comma-separated
		$smt=scalar (my @cpus = split m/,/); # count how many are there
	}else{
		$smt = `lscpu | grep "Thread.*per core" | cut -d':' -f2`;
		$smt =~ s/^\s*//; $smt =~ s/\s*$//;
		if($smt == 0){
			my $ncores=`ppc64_cpu --cores-on | cut -d'=' -f2 2>&1`; $ncores =~ s/^\s*//; $ncores =~ s/\s*$//;
			if($ncores!=0){
				$smt = (scalar @available_processors)/$ncores;	
			}
		}
	}
	if($smt==0){
		print "Note: Unable to determine SMT mode. Assuming SMT-1\n";
		$smt=1;
	}
	return $smt;
}
sub find_capi_devices
{
	if(! $usecapi){
		return ();
	}
	my @capi_devices;
	my $device = "'afu*'";
	#my $device = "'ttyS*'";
	my $capi_devices_str = `find /dev/cxl/ -type c -name $device | tr -s "\n" " "`;
	chomp($capi_devices_str);
	if(length $capi_devices_str)
	{
		@capi_devices = split(' ', $capi_devices_str);
	}
	return @capi_devices;
}
